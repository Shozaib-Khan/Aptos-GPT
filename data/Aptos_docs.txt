Start with Onboarding Tutorials
If you are new to the Aptos blockchain, begin with these quickstarts before you get into in-depth development. These tutorials will help you become familiar with how to develop for the Aptos blockchain using the Aptos SDK.

Your First Transaction
How to generate, submit and verify a transaction to the Aptos blockchain.

Your First NFT
Learn the Aptos token interface and how to use it to generate your first NFT. This interface is defined in the token.move Move module.

Your First Coin
Learn how to deploy and manage a coin. The coin interface is defined in the coin.move Move module.

Your First Fungible Asset
Learn how to deploy and manage a fungible asset. The fungible asset interface is defined in the fungible_asset.move Move module.

Your First Move Module
Write your first Move module for the Aptos blockchain.

Your First Dapp
Learn how to build your first dapp. Focuses on building the user interface for the dapp.

Your First Multisig
Learn how to perform assorted operations using K-of-N multisigner authentication.

Your First Transaction
This tutorial describes how to generate and submit transactions to the Aptos blockchain, and verify these submitted transactions. The transfer-coin example used in this tutorial is built with the Aptos SDKs.

Step 1: Pick an SDK
Install your preferred SDK from the below list:

TypeScript SDK
Python SDK
Rust SDK
Step 2: Run the example
Clone the aptos-core repo:

git clone https://github.com/aptos-labs/aptos-core.git

Typescript
Python
Rust
Navigate to the Typescript SDK examples directory:

cd ~/aptos-core/ecosystem/typescript/sdk/examples/typescript

Install the necessary dependencies:

pnpm install

Run the transfer_coin example:

pnpm run transfer_coin

Step 3: Understand the output
An output very similar to the following will appear after executing the above command:

=== Addresses ===
Alice: 0xbd20517751571ba3fd06326c23761bc0bc69cf450898ffb43412fbe670c28806
Bob: 0x8705f98a74f5efe17740276ed75031927402c3a965e10f2ee16cda46d99d8f7f

=== Initial Balances ===
Alice: 100000000
Bob: 0

=== Intermediate Balances ===
Alice: 99944900
Bob: 1000

=== Final Balances ===
Alice: 99889800
Bob: 2000

The above output demonstrates that the transfer-coin example executes the following steps:

Initializing the REST and faucet clients.
The creation of two accounts: Alice and Bob.
The funding and creation of Alice's account from a faucet.
The creation of Bob's account from a faucet.
The transferring of 1000 coins from Alice to Bob.
The 54100 coins of gas paid for by Alice to make that transfer.
Another transfer of 1000 coins from Alice to Bob.
The additional 54100 coins of gas paid for by Alice to make that transfer.
Now see the below walkthrough of the SDK functions used to accomplish the above steps.

Step 4: The SDK in depth
The transfer-coin example code uses helper functions to interact with the REST API. This section reviews each of the calls and gives insights into functionality.

Typescript
Python
Rust
SEE THE FULL CODE
See the TypeScript transfer-coin for the complete code as you follow the below steps.

Step 4.1: Initializing the clients
In the first step, the transfer-coin example initializes both the REST and faucet clients:

The REST client interacts with the REST API.
The faucet client interacts with the devnet Faucet service for creating and funding accounts.
Typescript
Python
Rust
const client = new AptosClient(NODE_URL);
const faucetClient = new FaucetClient(NODE_URL, FAUCET_URL); 

Using the API client we can create a CoinClient that we use for common coin operations such as transferring coins and checking balances.

const coinClient = new CoinClient(client); 

common.ts initializes the URL values as such:

export const NODE_URL = process.env.APTOS_NODE_URL || "https://fullnode.devnet.aptoslabs.com";
export const FAUCET_URL = process.env.APTOS_FAUCET_URL || "https://faucet.devnet.aptoslabs.com";

TIP
By default, the URLs for both the services point to Aptos devnet services. However, they can be configured with the following environment variables:

APTOS_NODE_URL
APTOS_FAUCET_URL
Step 4.2: Creating local accounts
The next step is to create two accounts locally. Accounts represent both on and off-chain state. Off-chain state consists of an address and the public/private key pair used to authenticate ownership. This step demonstrates how to generate that off-chain state.

Typescript
Python
Rust
const alice = new AptosAccount();
const bob = new AptosAccount(); 

Step 4.3: Creating blockchain accounts
In Aptos, each account must have an on-chain representation in order to receive tokens and coins and interact with other dApps. An account represents a medium for storing assets; hence, it must be explicitly created. This example leverages the Faucet to create and fund Alice's account and to create but not fund Bob's account:

Typescript
Python
Rust
await faucetClient.fundAccount(alice.address(), 100_000_000);
await faucetClient.fundAccount(bob.address(), 0); 

Step 4.4: Reading balances
In this step, the SDK translates a single call into the process of querying a resource and reading a field from that resource.

Typescript
Python
Rust
console.log(`Alice: ${await coinClient.checkBalance(alice)}`);
console.log(`Bob: ${await coinClient.checkBalance(bob)}`); 

Behind the scenes, the checkBalance function in CoinClient in the SDK queries the CoinStore resource for the AptosCoin and reads the current stored value:

async checkBalance(
  account: AptosAccount | MaybeHexString,
  extraArgs?: {
    // The coin type to use, defaults to 0x1::aptos_coin::AptosCoin.
    // If you want to check the balance of a fungible asset, set this param to be the
    // fungible asset address
    coinType?: string | MaybeHexString;
  },
): Promise<bigint> {
  // Since we can receive either a fully qualified type tag like "0x1::coin_type::CoinType"
  // or a fungible object address "0x1234...6789" we first check to see if the raw string value includes "::"
  // This is to make sure it's not supposed to be a fungible asset object address.
  const isTypeTag = (extraArgs?.coinType ?? "").toString().includes("::");

  // If the coin type exists, definitely isn't a type tag, and is a valid account address,
  // then we enter this if block under the assumption that it's a fungible asset object address.
  if (extraArgs?.coinType && !isTypeTag && AccountAddress.isValid(extraArgs.coinType)) {
    /* eslint-disable no-console */
    console.warn("to check balance of a fungible asset, use `FungibleAssetClient()` class for better support");
    const provider = new Provider({
      fullnodeUrl: this.aptosClient.nodeUrl,
      indexerUrl: NetworkToIndexerAPI[NodeAPIToNetwork[this.aptosClient.nodeUrl]] ?? this.aptosClient.nodeUrl,
    });
    const fungibleAsset = new FungibleAssetClient(provider);
    const balance = await fungibleAsset.getPrimaryBalance(
      getAddressFromAccountOrAddress(account),
      extraArgs?.coinType,
    );
    return balance;
  }

  const coinType = extraArgs?.coinType ?? APTOS_COIN;
  const typeTag = `0x1::coin::CoinStore<${coinType}>`;
  const address = getAddressFromAccountOrAddress(account);
  const accountResource = await this.aptosClient.getAccountResource(address, typeTag);
  return BigInt((accountResource.data as any).coin.value);
} 


Step 4.5: Transferring
Like the previous step, this is another helper step that constructs a transaction transferring the coins from Alice to Bob. For correctly generated transactions, the API will return a transaction hash that can be used in the subsequent step to check on the transaction status. The Aptos blockchain does perform a handful of validation checks on submission; and if any of those fail, the user will instead be given an error. These validations use the transaction signature and unused sequence number, and submitting the transaction to the appropriate chain.

Typescript
Python
Rust
let txnHash = await coinClient.transfer(alice, bob, 1_000, { gasUnitPrice: BigInt(100) }); 

Behind the scenes, the transfer function generates a transaction payload and has the client sign, send, and wait for it:

async transfer(
  from: AptosAccount,
  to: AptosAccount | MaybeHexString,
  amount: number | bigint,
  extraArgs?: OptionalTransactionArgs & {
    // The coin type to use, defaults to 0x1::aptos_coin::AptosCoin.
    // If you want to transfer a fungible asset, set this param to be the
    // fungible asset address
    coinType?: string | MaybeHexString;
    // If set, create the `receiver` account if it doesn't exist on-chain.
    // This is done by calling `0x1::aptos_account::transfer` instead, which
    // will create the account on-chain first if it doesn't exist before
    // transferring the coins to it.
    // If this is the first time an account has received the specified coinType,
    // and this is set to false, the transaction would fail.
    createReceiverIfMissing?: boolean;
  },
): Promise<string> {
  // Since we can receive either a fully qualified type tag like "0x1::coin_type::CoinType"
  // or a fungible object address "0x1234...6789" we first check to see if the raw string value includes "::"
  // This is to make sure it's not supposed to be a fungible asset object address.
  const isTypeTag = (extraArgs?.coinType ?? "").toString().includes("::");

  // If the coin type exists, definitely isn't a type tag, and is a valid account address,
  // then we enter this if block under the assumption that it's a fungible asset object address.
  if (extraArgs?.coinType && !isTypeTag && AccountAddress.isValid(extraArgs.coinType)) {
    /* eslint-disable no-console */
    console.warn("to transfer a fungible asset, use `FungibleAssetClient()` class for better support");
    const provider = new Provider({
      fullnodeUrl: this.aptosClient.nodeUrl,
      indexerUrl: NetworkToIndexerAPI[NodeAPIToNetwork[this.aptosClient.nodeUrl]] ?? this.aptosClient.nodeUrl,
    });
    const fungibleAsset = new FungibleAssetClient(provider);
    const txnHash = await fungibleAsset.transfer(
      from,
      extraArgs?.coinType,
      getAddressFromAccountOrAddress(to),
      amount,
    );
    return txnHash;
  }

  // If none is explicitly given, use 0x1::aptos_coin::AptosCoin as the coin type.
  const coinTypeToTransfer = extraArgs?.coinType ?? APTOS_COIN;

  // If we should create the receiver account if it doesn't exist on-chain,
  // use the `0x1::aptos_account::transfer_coins` function.
  let func: string;
  if (extraArgs?.createReceiverIfMissing === undefined) {
    func = TRANSFER_COINS;
  } else {
    func = extraArgs?.createReceiverIfMissing ? TRANSFER_COINS : COIN_TRANSFER;
  }

  // Get the receiver address from the AptosAccount or MaybeHexString.
  const toAddress = getAddressFromAccountOrAddress(to);

  const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: from.address(), ...extraArgs });
  const rawTxn = await builder.build(func, [coinTypeToTransfer as string], [toAddress, amount]);

  const bcsTxn = AptosClient.generateBCSTransaction(from, rawTxn);
  const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
  return pendingTransaction.hash;
} 


Within the client, generateSignSubmitTransaction is doing this:

const rawTransaction = await this.generateRawTransaction(sender.address(), payload, extraArgs);
const bcsTxn = AptosClient.generateBCSTransaction(sender, rawTransaction);
const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
return pendingTransaction.hash;


Breaking the above down into pieces:

transfer internally is a EntryFunction in the Coin Move module, i.e. an entry function in Move that is directly callable.
The Move function is stored on the coin module: 0x1::coin.
Because the Coin module can be used by other coins, the transfer must explicitly specify which coin type to transfer. If not specified with coinType it defaults to 0x1::aptos_coin::AptosCoin.
Step 4.6: Waiting for transaction resolution
Typescript
Python
Rust
In TypeScript, just calling coinClient.transfer is sufficient to wait for the transaction to complete. The function will return the Transaction returned by the API once it is processed (either successfully or unsuccessfully) or throw an error if processing time exceeds the timeout.

You can set checkSuccess to true when calling transfer if you'd like it to throw an error if the transaction was not committed successfully:

await client.waitForTransaction(txnHash); 

Supporting documentation
Account basics
TypeScript SDK
Python SDK
Rust SDK
REST API specification

Your First NFT
This tutorial describes how to create and transfer non-fungible assets on the Aptos blockchain. The Aptos no-code implementation for non-fungible digital assets can be found in the aptos_token.move Move module.

Step 1: Pick an SDK
Install your preferred SDK from the below list:

TypeScript SDK
Python SDK
Step 2: Run the example
Each SDK provides an examples directory. This tutorial covers the simple_aptos_token example.

Clone the aptos-core repo:

git clone git@github.com:aptos-labs/aptos-core.git ~/aptos-core

Typescript
Python
Navigate to the Typescript SDK examples directory:

cd ~/aptos-core/ecosystem/typescript/sdk/examples/typescript

Install the necessary dependencies:

pnpm install

Run the Typescript simple_aptos_token example:

pnpm run simple_aptos_token

Step 3: Understand the output
The following output should appear after executing the simple_aptos_token example, though some values will be different:

Typescript
Python
=== Addresses ===
Alice: 0x5acb91a64a2bbc5fc606a534709db5a1e60e439e15069d1e7bbaecddb4189b48
Bob: 0x612febb35dabc40df3260f7dd6c012f955671eb99862ba12390d2182ee3ab5de

=== Initial Coin Balances ===
Alice: 100000000
Bob: 100000000

=== Creating Collection and Token ===
Alice's collection: {
    "collection_id": "0x65b4000927646cae66251ed121f69ffa9acc2a6fb58a574fc66fd002b3d15d4f",
    "token_standard": "v2",
    "collection_name": "Alice's",
    "creator_address": "0x5acb91a64a2bbc5fc606a534709db5a1e60e439e15069d1e7bbaecddb4189b48",
    "current_supply": 1,
    "description": "Alice's simple collection",
    "uri": "https://alice.com"
}
Alice's token balance: 1
Alice's token data: {
    "token_data_id": "0xca2139c819fe03e2e268314c078948410dd14a64142ac270207a82cfddcc1fe7",
    "token_name": "Alice's first token",
    "token_uri": "https://aptos.dev/img/nyan.jpeg",
    "token_properties": {},
    "token_standard": "v2",
    "largest_property_version_v1": null,
    "maximum": null,
    "is_fungible_v2": false,
    "supply": 0,
    "last_transaction_version": 77174329,
    "last_transaction_timestamp": "2023-08-02T01:23:05.620127",
    "current_collection": {
        "collection_id": "0x65b4000927646cae66251ed121f69ffa9acc2a6fb58a574fc66fd002b3d15d4f",
        "collection_name": "Alice's",
        "creator_address": "0x5acb91a64a2bbc5fc606a534709db5a1e60e439e15069d1e7bbaecddb4189b48",
        "uri": "https://alice.com",
        "current_supply": 1
    }
}

=== Transferring the token to Bob ===
Alice's token balance: 0
Bob's token balance: 1

=== Transferring the token back to Alice ===
Alice's token balance: 1
Bob's token balance: 0

=== Checking if indexer devnet chainId same as fullnode chainId  ===
Fullnode chain id is: 67, indexer chain id is: 67

=== Getting Alices's NFTs ===
Alice current token ownership: 1. Should be 1

=== Getting Bob's NFTs ===
Bob current token ownership: 0. Should be 0

This example demonstrates:

Initializing the REST and faucet clients.
The creation of two accounts: Alice and Bob.
The funding and creation of Alice and Bob's accounts.
The creation of a collection and a token using Alice's account.
Alice sending a token to Bob.
Bob sending the token back to Alice.
Step 4: The SDK in depth
Typescript
Python
SEE THE FULL CODE
See simple_aptos_token for the complete code as you follow the below steps.

Step 4.1: Initializing the clients
In the first step, the example initializes both the API and faucet clients.

The API client interacts with the REST API.
The faucet client interacts with the devnet Faucet service for creating and funding accounts.
Typescript
Python
const provider = new Provider(Network.DEVNET);
const faucetClient = new FaucetClient(NODE_URL, FAUCET_URL); 

Using the API client we can create a TokenClient that we use for common token operations such as creating collections and tokens, transferring them, claiming them, and so on.

const aptosTokenClient = new AptosToken(provider); 

common.ts initializes the URL values as such:

export const NODE_URL = process.env.APTOS_NODE_URL || "https://fullnode.devnet.aptoslabs.com";
export const FAUCET_URL = process.env.APTOS_FAUCET_URL || "https://faucet.devnet.aptoslabs.com";

TIP
By default, the URLs for both the services point to Aptos devnet services. However, they can be configured with the following environment variables:

APTOS_NODE_URL
APTOS_FAUCET_URL
Step 4.2: Creating local accounts
The next step is to create two accounts locally. Accounts consist of a public address and the public/private key pair used to authenticate ownership of the account. This step demonstrates how to generate an Account and store its key pair and address in a variable.

Typescript
Python
const alice = new AptosAccount();
const bob = new AptosAccount(); 

INFO
Note that this only generates the local keypair. After generating the keypair and public address, the account still does not exist on-chain.

Step 4.3: Creating blockchain accounts
In order to actually instantiate the Account on-chain, it must be explicitly created somehow. On the devnet network, you can request free coins with the Faucet API to use for testing purposes. This example leverages the faucet to fund and inadvertently create Alice and Bob's accounts:

Typescript
Python
await faucetClient.fundAccount(alice.address(), 100_000_000);
await faucetClient.fundAccount(bob.address(), 100_000_000); 

Step 4.4: Creating a collection
Now begins the process of creating the digital, non-fungible assets. First, as the creator, you must create a collection that groups the assets. A collection can contain zero, one, or many distinct fungible or non-fungible assets within it. The collection is simply a container, intended only to group assets for a creator.

Typescript
Python
Your application will call createCollection:

const txnHash1 = await aptosTokenClient.createCollection(
  alice,
  "Alice's simple collection",
  collectionName,
  "https://alice.com",
  maxSupply,
  {
    royaltyNumerator: 5,
    royaltyDenominator: 100,
  },
); 

This is the function signature of createCollection. It returns a transaction hash:

async createCollection(
  creator: AptosAccount,
  description: string,
  name: string,
  uri: string,
  maxSupply: AnyNumber = MAX_U64_BIG_INT,
  options?: CreateCollectionOptions,
  extraArgs?: OptionalTransactionArgs,
): Promise<string> {
  

Step 4.5: Creating a token
To create a token, the creator must specify an associated collection. A token must be associated with a collection, and that collection must have remaining tokens that can be minted. There are many attributes associated with a token, but the helper API exposes only the minimal amount required to create static content.

Typescript
Python
Your application will call mint:

const txnHash2 = await aptosTokenClient.mint(
  alice,
  collectionName,
  "Alice's simple token",
  tokenName,
  "https://aptos.dev/img/nyan.jpeg",
  [],
  [],
  [],
); 

This is the function signature of mint. It returns a transaction hash:

async mint(
  account: AptosAccount,
  collection: string,
  description: string,
  name: string,
  uri: string,
  propertyKeys: Array<string> = [],
  propertyTypes: Array<string> = [],
  propertyValues: Array<string> = [],
  extraArgs?: OptionalTransactionArgs,
): Promise<string> {
  

Step 4.6: Reading token and collection metadata
Both the collection and token assets are Objects on-chain with unique addresses. Their metadata is stored at the object address. The SDKs provide convenience wrappers around querying this data:

Typescript
Python
To read a collection's metadata:

const collectionData = (await provider.getCollectionData(alice.address(), collectionName)).current_collections_v2[0];
console.log(`Alice's collection: ${JSON.stringify(collectionData, null, 4)}`); 


To read a token's metadata:

const tokenData = (await provider.getTokenData(tokenAddress.toString())).current_token_datas_v2[0];
console.log(`Alice's token data: ${JSON.stringify(tokenData, null, 4)}`); 

Here's how getTokenData queries the token metadata using the indexer client:

async getTokenData(
  token: string,
  extraArgs?: {
    tokenStandard?: TokenStandard;
    options?: IndexerPaginationArgs;
    orderBy?: IndexerSortBy<Current_Token_Datas_V2_Order_By>[];
  },
): Promise<GetTokenDataQuery> {
  const tokenAddress = HexString.ensure(token).hex();
  IndexerClient.validateAddress(tokenAddress);

  const whereCondition: any = {
    token_data_id: { _eq: tokenAddress },
  };

  if (extraArgs?.tokenStandard) {
    whereCondition.token_standard = { _eq: extraArgs?.tokenStandard };
  }
  const graphqlQuery = {
    query: GetTokenData,
    variables: {
      where_condition: whereCondition,
      offset: extraArgs?.options?.offset,
      limit: extraArgs?.options?.limit,
      order_by: extraArgs?.orderBy,
    },
  };
  return this.queryIndexer(graphqlQuery);
} 

Step 4.7: Reading an object's owner
Each object created from the aptos_token.move contract is a distinct asset. The assets owned by a user are stored separately from the user's account. To check if a user owns an object, check the object's owner:

Typescript
Python
Extracting the balance from the indexer query
const collectionAddress = HexString.ensure(collectionData.collection_id);
let { tokenAddress, amount: aliceAmount } = await getTokenInfo(provider, alice.address(), collectionAddress);
console.log(`Alice's token balance: ${aliceAmount}`); 


Making the query to get the data
async function getTokenInfo(
  provider: Provider,
  ownerAddress: HexString,
  collectionAddress: HexString,
): Promise<{ tokenAddress?: HexString; amount: number }> {
  const tokensOwnedQuery = await provider.getTokenOwnedFromCollectionAddress(
    ownerAddress,
    collectionAddress.toString(),
    {
      tokenStandard: "v2",
    },
  );
  const tokensOwned = tokensOwnedQuery.current_token_ownerships_v2.length;
  if (tokensOwned > 0) {
    return {
      tokenAddress: HexString.ensure(tokensOwnedQuery.current_token_ownerships_v2[0].current_token_data.token_data_id),
      amount: tokensOwnedQuery.current_token_ownerships_v2[0].amount,
    };
  } else {
    return {
      tokenAddress: undefined,
      amount: tokensOwned,
    };
  }
} 


Step 4.8: Transfer the object back and forth
Each object created from the aptos_token.move contract is a distinct asset. The assets owned by a user are stored separately from the user's account. To check if a user owns an object, check the object's owner:

Typescript
Python
Extracting the balance from the indexer query
const collectionAddress = HexString.ensure(collectionData.collection_id);
let { tokenAddress, amount: aliceAmount } = await getTokenInfo(provider, alice.address(), collectionAddress);
console.log(`Alice's token balance: ${aliceAmount}`); 


Making the query to get the data
async function getTokenInfo(
  provider: Provider,
  ownerAddress: HexString,
  collectionAddress: HexString,
): Promise<{ tokenAddress?: HexString; amount: number }> {
  const tokensOwnedQuery = await provider.getTokenOwnedFromCollectionAddress(
    ownerAddress,
    collectionAddress.toString(),
    {
      tokenStandard: "v2",
    },
  );
  const tokensOwned = tokensOwnedQuery.current_token_ownerships_v2.length;
  if (tokensOwned > 0) {
    return {
      tokenAddress: HexString.ensure(tokensOwnedQuery.current_token_ownerships_v2[0].current_token_data.token_data_id),
      amount: tokensOwnedQuery.current_token_ownerships_v2[0].amount,
    };
  } else {
    return {
      tokenAddress: undefined,
      amount: tokensOwned,
    };
  }
} 


Transfer the token from Alice to Bob
const txnHash3 = await aptosTokenClient.transferTokenOwnership(alice, tokenAddress, bob.address()); 

Print each user's queried token amount
aliceAmount = (await getTokenInfo(provider, alice.address(), collectionAddress)).amount;
let bobAmount = (await getTokenInfo(provider, bob.address(), collectionAddress)).amount;
console.log(`Alice's token balance: ${aliceAmount}`);
console.log(`Bob's token balance: ${bobAmount}`); 

Transfer the token back to Alice
let txnHash4 = await aptosTokenClient.transferTokenOwnership(bob, tokenAddress, alice.address()); 

Print each user's queried token amount again
aliceAmount = (await getTokenInfo(provider, alice.address(), collectionAddress)).amount;
bobAmount = (await getTokenInfo(provider, bob.address(), collectionAddress)).amount;
console.log(`Alice's token balance: ${aliceAmount}`);
console.log(`Bob's token balance: ${bobAmount}`); 

Supporting documentation
Account basics
TypeScript SDK
Python SDK
REST API specification

Your First Coin
This tutorial introduces how you can compile, deploy, and mint your own coin, named MoonCoin.

Step 1: Pick an SDK
Install your preferred SDK from the below list:

TypeScript SDK
Python SDK
Rust SDK
Step 2: Install the CLI
Install the precompiled binary for the Aptos CLI.

Step 3: Run the example
Clone the aptos-core repo:

git clone https://github.com/aptos-labs/aptos-core.git

Typescript
Python
Rust
Navigate to the TypeScript SDK directory:

cd ~/aptos-core/ecosystem/typescript/sdk

Install the necessary dependencies:

pnpm install

Run the TypeScript your_coin example:

cd examples/typescript
pnpm your_coin ~/aptos-core/aptos-move/move-examples/moon_coin

Step 3.1: Build the package
The example run will pause with the following output:

=== Addresses ===
Alice: 0x5e603a89cf690d7134cf2f24fdb16ba90c4f5686333721c12e835fb6c76bc7ba
Bob: 0xc8421fa4a99153f955e50f1de2a6acff2f3fd0bb33aa17ba1f5b32b699f6c825

Update the package with Alice's address, compile, and press enter.

At this point, open another terminal and change directories to the MoonCoin package's directory:

cd ~/aptos-core/aptos-move/move-examples/moon_coin

Next, build the package using the CLI:

aptos move compile --named-addresses MoonCoin=0x5e603a89cf690d7134cf2f24fdb16ba90c4f5686333721c12e835fb6c76bc7ba --save-metadata


The --named-addresses is a list of address mappings that must be translated in order for the package to be compiled to be stored in Alice's account. Notice how MoonCoin is set to Alice's address printed above. Also --save-metadata is required to publish the package.

Step 3.2: Completing the example
Returning to the previous prompt, press ENTER as the package is now ready to be published.

The application will complete, printing:


Publishing MoonCoin package.

Bob registers the newly created coin so he can receive it from Alice.
Bob's initial MoonCoin balance: 0.
Alice mints Bob some of the new coin.
Bob's updated MoonCoin balance: 100.

Step 4: MoonCoin in depth
Step 4.1: Building and publishing the MoonCoin package
Move contracts are effectively a set of Move modules known as a package. When deploying or upgrading a new package, the compiler must be invoked with --save-metadata to publish the package. In the case of MoonCoin, the following output files are critical:

build/Examples/package-metadata.bcs: Contains the metadata associated with the package.
build/Examples/bytecode_modules/moon_coin.mv: Contains the bytecode for the moon_coin.move module.
These are read by the example and published to the Aptos blockchain:

Typescript
Python
Rust
const modulePath = process.argv[2];
const packageMetadata = fs.readFileSync(path.join(modulePath, "build", "Examples", "package-metadata.bcs"));
const moduleData = fs.readFileSync(path.join(modulePath, "build", "Examples", "bytecode_modules", "moon_coin.mv"));

console.log("Publishing MoonCoin package.");
let txnHash = await client.publishPackage(alice, new HexString(packageMetadata.toString("hex")).toUint8Array(), [
  new TxnBuilderTypes.Module(new HexString(moduleData.toString("hex")).toUint8Array()),
]);
await client.waitForTransaction(txnHash, { checkSuccess: true }); 


Step 4.2: Understanding the MoonCoin module
The MoonCoin module defines the MoonCoin struct, or the distinct type of coin type. In addition, it contains a function called init_module. The init_module function is called when the module is published. In this case, MoonCoin initializes the MoonCoin coin type as a ManagedCoin, which is maintained by the owner of the account.

MANAGEDCOIN FRAMEWORK
ManagedCoin is a simple coin management framework for coins directly managed by users. It provides convenience wrappers around mint and burn.

module MoonCoin::moon_coin {
    struct MoonCoin {}

    fun init_module(sender: &signer) {
        aptos_framework::managed_coin::initialize<MoonCoin>(
            sender,
            b"Moon Coin",
            b"MOON",
            6,
            false,
        );
    }
}

Step 4.3: Understanding coins
Coins have several primitives:

Minting: Creating new coins.
Burning: Deleting coins.
Freezing: Preventing an account from storing coins in CoinStore.
Registering: Creating a CoinStore resource on an account for storing coins.
Transferring: Withdrawing and depositing coins into CoinStore.
TIP
The entity that creates a new coin gains the capabilities for minting, burning, and freezing.

Step 4.3.1: Initializing a coin
Once a coin type has been published to the Aptos blockchain, the entity that published that coin type can initialize it:

public fun initialize<CoinType>(
    account: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool,
): (BurnCapability<CoinType>, FreezeCapability<CoinType>, MintCapability<CoinType>) {
    let account_addr = signer::address_of(account);

    assert!(
        coin_address<CoinType>() == account_addr,
        error::invalid_argument(ECOIN_INFO_ADDRESS_MISMATCH),
    );

    assert!(
        !exists<CoinInfo<CoinType>>(account_addr),
        error::already_exists(ECOIN_INFO_ALREADY_PUBLISHED),
    );

    let coin_info = CoinInfo<CoinType> {
        name,
        symbol,
        decimals,
        supply: if (monitor_supply) { option::some(optional_aggregator::new(MAX_U128, false)) } else { option::none() },
    };
    move_to(account, coin_info);

    (BurnCapability<CoinType>{ }, FreezeCapability<CoinType>{ }, MintCapability<CoinType>{ })
}


This ensures that this coin type has never been initialized before. Notice the check on lines 10 and 15 to ensure that the caller to initialize is the same one that actually published this module, and that there is no CoinInfo stored on their account. If both those conditions check, then a CoinInfo is stored and the caller obtains capabilities for burning, freezing, and minting.

TIP
MoonCoin calls this initialize function automatically upon package publishing.

Step 4.3.2: Registering a coin
To use a coin, an entity must register a CoinStore for it on their account:

public entry fun registerCoinType(account: &signer) {

MoonCoin uses ManagedCoin that provides an entry function wrapper: managed_coin::register. Here is an example script for registration:

script {
    fun register(account: &signer) {
        aptos_framework::managed_coin::register<MoonCoin::moon_coin::MoonCoin>(account)
    }
}

Step 4.3.3: Minting a coin
Minting coins requires the mint capability that was produced during initialization. the function mint (see below) takes in that capability and an amount, and returns back a Coin<T> struct containing that amount of coins. If the coin tracks supply, it will be updated.

public fun mint<CoinType>(
    amount: u64,
    _cap: &MintCapability<CoinType>,
): Coin<CoinType> acquires CoinInfo {
    if (amount == 0) {
        return zero<CoinType>()
    };

    let maybe_supply = &mut borrow_global_mut<CoinInfo<CoinType>>(coin_address<CoinType>()).supply;
    if (option::is_some(maybe_supply)) {
        let supply = option::borrow_mut(maybe_supply);
        optional_aggregator::add(supply, (amount as u128));
    };

    Coin<CoinType> { value: amount }
}

ManagedCoin makes this easier by providing an entry function managed_coin::mint.

Step 4.3.4: Transferring a coin
Aptos provides several building blocks to support coin transfers:

coin::deposit<CoinType>: Allows any entity to deposit a coin into an account that has already called coin::register<CoinType>.
coin::withdraw<CoinType>: Allows any entity to extract a coin amount from their account.
aptos_account::transfer_coins<CoinType>: Transfer coins of specific CoinType to a receiver.
IMPORTANT
There are two separate withdraw and deposit events instead of a single transfer event.

Supporting documentation
Aptos CLI
TypeScript SDK
Python SDK
Rust SDK
REST API specification

Your First Fungible Asset
This tutorial introduces how you can compile, deploy, and mint your own fungible asset (FA), named FACoin. Make sure you have understood FA before moving on to the tutorial. If not, it is highly recommended to read it first.

Fungible Asset
Step 1: Pick an SDK
Install your preferred SDK from the below list:

TypeScript SDK
Python SDK
Rust SDK
Step 2: Install the CLI
Install the precompiled binary for the Aptos CLI.

Step 3: Run the example
Clone the aptos-core repo:

git clone https://github.com/aptos-labs/aptos-core.git

Typescript
Python
Rust
Navigate to the TypeScript SDK directory:

cd ~/aptos-core/ecosystem/typescript/sdk/examples/typescript

Install the necessary dependencies:

pnpm install

Run the TypeScript your_fungible_asset example:

pnpm your_fungible_asset ~/aptos-core/aptos-move/move-examples/fungible_asset/fa_coin

Step 3.1: Build the package
The example run will pause with the following output:

=== Addresses ===
Alice: 0xa816be8abfbcb2c61fd5032715a8ff4155fd19ad67b379c4482bf0a10d320ed9
Bob: 0xcdbbbb3b6ad9902b49b9055fa907272a701c00abcaf1ea59a4b1ae1ba761bb69
Charlie: 0xe664111a5e56f69128b72fcc30c1b41745b74d7a51e3528b5e110cad8203b3e6
Update the package with Alice's address, compile, and press enter.

At this point, open another terminal and change directories to the FACoin package's directory:

cd ~/aptos-core/aptos-move/move-examples/fungible_asset/fa_coin

Next, build the package using the CLI with FACoin=${Alice address}:

aptos move compile --named-addresses FACoin=0xa816be8abfbcb2c61fd5032715a8ff4155fd19ad67b379c4482bf0a10d320ed9 --save-metadata


The --named-addresses is a list of address mappings that must be translated in order for the package to be compiled to be stored in Alice's account. Notice how FACoin is set to Alice's address printed above. Also --save-metadata is required to publish the package.

Step 3.2: Completing the example
Returning to the previous prompt, press ENTER as the package is now ready to be published.

The application will complete, printing:

Publishing FACoin package.

All the balances in this example refer to balance in primary fungible stores of each account.
Alice's initial FACoin balance: 0.
Bob's initial FACoin balance: 0.
Charlie's initial balance: 0.
Alice mints Charlie 100 coins.
Charlie's updated FACoin primary fungible store balance: 100.
Alice freezes Bob's account.
Alice as the admin forcefully transfers the newly minted coins of Charlie to Bob ignoring that Bob's account is frozen.
Bob's updated FACoin balance: 100.
Alice unfreezes Bob's account.
Alice burns 50 coins from Bob.
Bob's updated FACoin balance: 50.
Bob transfers 10 coins to Alice as the owner.
Alice's updated FACoin balance: 10.
Bob's updated FACoin balance: 40.


Step 4: FACoin in depth
Step 4.1: Building and publishing the FACoin package
Move contracts are effectively a set of Move modules known as a package. When deploying or upgrading a new package, the compiler must be invoked with --save-metadata to publish the package. In the case of FACoin, the following output files are critical:

build/Examples/package-metadata.bcs: Contains the metadata associated with the package.
build/Examples/bytecode_modules/fa_coin.mv: Contains the bytecode for the fa_coin.move module.
These are read by the example and published to the Aptos blockchain:

Typescript
Python
Rust
const modulePath = process.argv[2];
const packageMetadata = fs.readFileSync(path.join(modulePath, "build", "Examples", "package-metadata.bcs"));
const moduleData = fs.readFileSync(path.join(modulePath, "build", "Examples", "bytecode_modules", "fa_coin.mv"));

console.log("Publishing FACoin package.\n");
let txnHash = await client.publishPackage(alice, new HexString(packageMetadata.toString("hex")).toUint8Array(), [
  new TxnBuilderTypes.Module(new HexString(moduleData.toString("hex")).toUint8Array()),
]);
await client.waitForTransaction(txnHash, { checkSuccess: true }); 


Step 4.2: Understanding the FACoin module
The FACoin module contains a function called init_module in which it creates a named metadata object that defines a type of FA called "FACoin" with a bunch of properties. The init_module function is called when the module is published. In this case, FACoin initializes the FACoin metadata object, owned by the owner of the account. According to the module code, the owner will be the admin of "FACoin" so that they are entitled to manage "FACoin" under the fungible asset framework.

MANAGED FUNGIBLE ASSET FRAMEWORK
Managed Fungible Asset is a full-fledged FA management framework for FAs directly managed by users. It provides convenience wrappers around different refs and both primary and secondary fungible stores. This example is a simplified version that only deal with primary stores.

Step 4.3: Understanding the management primitives of FACoin
The creator of FACoin have several managing primitives:

Minting: Creating new coins.
Burning: Deleting coins.
Freezing/Unfreezing: Disabling/Enabling the owner of an account to withdraw from or deposit to their primary fungible store of FACoin.
Withdraw: Withdrawing FACoin from the primary store of any account regardless of being frozen or not.
Deposit: Deposit FACoin from the primary store of any account regardless of being frozen or not.
Transfer: Withdraw from one account and deposit to another regardless of either being frozen or not.
TIP
The entity that creates FACoin gains the capabilities for minting, burning, freezing/unfreezing, and forceful transferring between any fungible stores no matter they are frozen or not. So Withdraw, Deposit, and Transfer in the management module have different semantics than those described in fungible asset framework that limited by frozen status.

Step 4.3.1: Initializing "FACoin" metadata object
After publishing the module to the Aptos blockchain, the entity that published that coin type should initialize a metadata object describing the information about this FA:

fa_coin.move snippet
fun init_module(admin: &signer) {
    let constructor_ref = &object::create_named_object(admin, ASSET_SYMBOL);
    primary_fungible_store::create_primary_store_enabled_fungible_asset(
        constructor_ref,
        option::none(),
        utf8(b"FA Coin"), /* name */
        utf8(ASSET_SYMBOL), /* symbol */
        8, /* decimals */
        utf8(b"http://example.com/favicon.ico"), /* icon */
        utf8(b"http://example.com"), /* project */
    );

    // Create mint/burn/transfer refs to allow creator to manage the fungible asset.
    let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
    let burn_ref = fungible_asset::generate_burn_ref(constructor_ref);
    let transfer_ref = fungible_asset::generate_transfer_ref(constructor_ref);
    let metadata_object_signer = object::generate_signer(constructor_ref);
    move_to(
        &metadata_object_signer,
        ManagedFungibleAsset { mint_ref, transfer_ref, burn_ref }
    )

This ensures that this FA type has never been initialized before using a named object. Notice the first line create a named object with a static seed, if the metadata object has been created it will abort. Then we call primary_fungible_store::create_primary_store_enabled_fungible_asset to create a FA metadata resource inside the newly created object, most of the time you call this function to initialize the metadata object. After this call, we generate all the Refs that are necessary for the management api and store them in a customized wrapper resource.

TIP
FACoin does all the initialization automatically upon package publishing via init_module(&signer).

Different from coin module, FA doesn't require users to register to use it because primary store will be automatically created if necessary.

Step 4.3.3: Managing a coin
Minting coins requires MintRef that was produced during initialization. the function mint (see below) takes in the creator and an amount, and returns a FungibleAsset struct containing that amount of FA. If the FA tracks supply, it will be updated.

fa_coin.move snippet
/// Mint as the owner of metadata object.
public entry fun mint(admin: &signer, to: address, amount: u64) acquires ManagedFungibleAsset {
    let asset = get_metadata();
    let managed_fungible_asset = authorized_borrow_refs(admin, asset);
    let to_wallet = primary_fungible_store::ensure_primary_store_exists(to, asset);
    let fa = fungible_asset::mint(&managed_fungible_asset.mint_ref, amount);
    fungible_asset::deposit_with_ref(&managed_fungible_asset.transfer_ref, to_wallet, fa);
}

FACoin makes this easier by providing an entry function fa_coin::mint that accesses the required MintRef for the creator.

Similarly, the module provides burn, set_frozen_flag, transfer, Withdraw and Deposit functions to manage FACoin following the same pattern with different refs.

Step 4.3.4: API of Transferring FAs
Aptos provides several APIs to support FA flows with same names in different modules:

fungible_asset::{transfer/withdraw/deposit}: Move FA between different unfrozen fungible stores objects.
fungible_asset::{transfer/withdraw/deposit}_with_ref: Move FA between different fungible stores objects with the corresponding TransferRef regardless of their frozen status.
primary_fungible_store::{transfer/withdraw/deposit}: Move FA between unfrozen primary stores of different accounts.
IMPORTANT
There are two separate withdraw and deposit events instead of a single transfer event.

Supporting documentation
Aptos CLI
Fungible Asset
TypeScript SDK
Python SDK
Rust SDK
REST API specification

Your First Move Module
This tutorial details how to compile, test, publish and interact with Move modules on the Aptos blockchain. The steps in summary are:

Install the precompiled binary for the Aptos CLI.
Create an account on the Aptos blockchain and fund it.
Compile and test a Move module.
Publish a Move module to the Aptos blockchain.
Interact with a Move module.
Step 1: Install the CLI
Install the precompiled binary for the Aptos CLI.

Step 2: Create an account and fund it
After installing the CLI binary, create and fund an account on the Aptos blockchain.

Start a new terminal and run the following command to initialize a new local account:

aptos init

You will see output asking to choose a network:

Choose network from [devnet, testnet, mainnet, local, custom | defaults to devnet]

Press return to accept the default devnet network or specify the network of your choosing:

No network given, using devnet...

See and respond to the prompt for your private key by accepting the default to create a new or by entering an existing key:

Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]


Assuming you elected to create a new, you will see:

No key given, generating key...
Account a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a doesn't exist, creating it and funding it with 100000000 Octas
Account a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a funded successfully

---
Aptos CLI is now set up for account a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a as profile default!  Run `aptos --help` for more information about commands
{
  "Result": "Success"
}


The account address in the above output a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a is your new account and is aliased as the profile default. This account address will be different for you as it is generated randomly. From now on, either default or 0xa345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a are used interchangeably in this document. Of course, substitute your own address as needed.

Now fund this account by running this command:

aptos account fund-with-faucet --account default

You will see output resembling:

{
  "Result": "Added 100000000 Octas to account a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a"
}


Step 3: Compile and test the module
Several example Move modules are available in the aptos-core/aptos-move/move-examples directory for your use. Open a terminal and change directories into the hello_blockchain directory:

cd aptos-core/aptos-move/move-examples/hello_blockchain

Run the below command to compile the hello_blockchain module:

aptos move compile --named-addresses hello_blockchain=default

You will see output resembling:

{
  "Result": [
    "a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a::message"
  ]
}

The compile command must contain --named-addresses as above because the Move.toml file leaves this as undefined (see below).

To test the module run:

aptos move test --named-addresses hello_blockchain=default

And receive output like:

INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING Examples
Running Move unit tests
[ PASS    ] 0x1a42874787568af30c785622899a27dacce066d671fa487e7fb958d6d0c85077::message::sender_can_set_message
[ PASS    ] 0x1a42874787568af30c785622899a27dacce066d671fa487e7fb958d6d0c85077::message_tests::sender_can_set_message
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}


To prepare the module for the account created in the previous step, we specify that the named address hello_blockchain is set to our account address, using the default profile alias.

[addresses]
hello_blockchain = "_"

Step 4: Publish the Move module
After the code is compiled and tested, we can publish the module to the account created for this tutorial with the command:

aptos move publish --named-addresses hello_blockchain=default

You will see the output similar to:

package size 1631 bytes
{
  "Result": {
    "transaction_hash": "0x45d682997beab297a9a39237c588d31da1cd2c950c5ab498e37984e367b0fc25",
    "gas_used": 13,
    "gas_unit_price": 1,
    "pending": null,
    "sender": "a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a",
    "sequence_number": 8,
    "success": true,
    "timestamp_us": 1661320216343795,
    "version": 3977,
    "vm_status": "Executed successfully"
  }
}

At this point, the module is now stored on the account in the Aptos blockchain.

Step 5: Interact with the Move module
Move modules expose access points, known as entry functions. These entry functions can be called via transactions. The Aptos CLI allows for seamless access to these entry functions. The example Move module hello_blockchain exposes a set_message entry function that takes in a string. This can be called via the CLI:

aptos move run \
  --function-id 'default::message::set_message' \
  --args 'string:hello, blockchain'

Upon success, the CLI will print out the following:

{
  "Result": {
    "transaction_hash": "0x1fe06f61c49777086497b199f3d4acbee9ea58976d37fdc06d1ea48a511a9e82",
    "gas_used": 1,
    "gas_unit_price": 1,
    "pending": null,
    "sender": "a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a",
    "sequence_number": 1,
    "success": true,
    "timestamp_us": 1661320878825763,
    "version": 5936,
    "vm_status": "Executed successfully"
  }
}

The set_message function modifies the hello_blockchain MessageHolder resource. A resource is a data structure that is stored in global storage. The resource can be read by querying the following REST API:


https://fullnode.devnet.aptoslabs.com/v1/accounts/a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a/resource/0xa345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a::message::MessageHolder


After the first execution, this should contain:

{
  "type":"0xa345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a::message::MessageHolder",
  "data":{
    "message":"hello, blockchain",
    "message_change_events":{
      "counter":"0",
      "guid":{
        "id":{
          "addr":"0xa345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a",
          "creation_num":"3"
        }
      }
    }
  }
}


Notice that the message field contains hello, blockchain.

Each successful call to set_message after the first call results in an update to message_change_events. The message_change_events for a given account can be accessed via the REST API:

https://fullnode.devnet.aptoslabs.com/v1/accounts/0xa345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a/events/0xa345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a::message::MessageHolder/message_change_events


where, after a call to set the message to hello, blockchain, again, the event stream would contain the following:

[
  {
    "version":"8556",
    "key":"0x0300000000000000a345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a",
    "sequence_number":"0","type":"0xa345dbfb0c94416589721360f207dcc92ecfe4f06d8ddc1c286f569d59721e5a::message::MessageChangeEvent",
    "data":{
      "from_message":"hello, blockchain",
      "to_message":"hello, blockchain, again"
    }
  }
]


TIP
Other accounts can reuse the published module by calling the exact same function as in this example. It is left as an exercise to the reader.

Supporting documentation
Account basics
TypeScript SDK
Python SDK
Rust SDK
REST API specification

Your First Dapp
In this tutorial, you will learn how to build a dapp on the Aptos blockchain. A dapp usually consists of a graphical user interface, which interacts with one or more Move modules. This dapp will let users publish and share snippets of text on the Aptos blockchain.

For this tutorial, we will use the Move module hello_blockchain described in Your First Move Module and focus on building the user interface around the module.

For a more comprehensive view of this process, see Build an End-to-End Dapp on Aptos.

We will use the:

TypeScript SDK
Petra Wallet
Aptos CLI
FULL SOURCE CODE
We recommend becoming familiar with the newer full source code documented in the Build an End-to-End Dapp on Aptos tutorial. The full source code for this tutorial is still available in the dapp-example directory.

Prerequisites
Aptos Wallet
Before starting this tutorial, you'll need a chrome extension wallet to interact with the dapp, such as, the Petra wallet extension.

If you haven't installed the Petra wallet extension before:

Open the Wallet and click Create a new wallet. Then click Create account to create an Aptos Account.
Copy the private key. You will need it to set up the Aptos CLI in the next section.
See the user instructions on petra.app for help.
Switch to the Devnet network by clicking, settings, network, and selecting devnet.
Click the faucet button to ensure you can receive test tokens.
If you already have the Petra wallet installed, we suggest you create a new wallet for purposes of this tutorial.

In the extension, go to settings, switch account, add account, create new account to create a new account.
Switch to the Devnet network by clicking, settings, network, and selecting devnet.
Click the faucet button to ensure you can receive test tokens.
TIP
Ensure your account has sufficient funds to perform transactions by clicking the Faucet button.

Aptos CLI
We will also be installing the Aptos CLI so that we can publish

Install the Aptos CLI.

Run aptos init --profile my-first-nft.

Select the network devnet

When prompted for your private key, paste the private key from the Petra Wallet and press Return.

You can find the private key by going to settings, manage account, show the private key, and copy that field.
You will see output resembling:

Account <account-number> has been already found onchain

---
Aptos CLI is now set up for account <account-number> as profile my-first-nft!  Run `aptos --help` for more information about commands
{
  "Result": "Success"
}


This initializes the Aptos CLI to use the same account as used by the Aptos Wallet.

Run aptos account list --profile my-first-nft to verify that it is working. You should see your account address listed in the addr field for all events.
Step 1: Set up a single page app
We will now set up the frontend user interface for our dapp. We will use create-react-app to set up the app in this tutorial, but neither React nor create-react-app are required. You can use your preferred JavaScript framework.

First run:

npx create-react-app first-dapp --template typescript

Accept installation of the create-react-app package if prompted. Then navigate to the newly created first-dapp directory:

cd first-dapp

And start the app with:

npm start

You will now have a basic React app running in your browser at: http://localhost:3000/

Step 2: Integrate the Aptos Wallet Web3 API
The Aptos Wallet provides a Web3 API for dapps at window.aptos. You can see how it works by opening up the browser console and running await window.aptos.account(). It will print out the address corresponding to the account you set up in the Aptos Wallet.

Next we will update our app to use this API to display the Wallet account's address.

Wait until window.aptos is defined
The first step when integrating with the window.aptos API is to delay rendering the application until the window.onload event has fired.

Quit the app by hitting Ctrl-C in the terminal running the npm start process.

Still in the first-dapp directory, open the src/index.tsx file and change the following code snippet:

root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

to this:

window.addEventListener('load', () => {
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
});

This change will ensure that the window.aptos API has been initialized by the time we render the app. If we render too early, the Wallet extension may not have had a chance to initialize the API yet and thus window.aptos will be undefined.

To see the change, once again run: npm start

(Optional) TypeScript setup for window.aptos
If you are using TypeScript, you may also want to inform the compiler of the existence of the window.aptos API. Add the following to src/index.tsx:

declare global {
  interface Window { aptos: any; }
}

This lets us use the window.aptos API without having to do (window as any).aptos.

Display window.aptos.account() in the app
Our app is now ready to use the window.aptos API. We will change src/App.tsx to retrieve the value of window.aptos.account() (the wallet account) on initial render, store it in state, and then display it by replacing the contents in the file with:

import React from 'react';
import './App.css';

function App() {
  // Retrieve aptos.account on initial render and store it.
  const [address, setAddress] = React.useState<string | null>(null);
  
  /**
   * init function
   */
  const init = async() => {
    // connect
    const { address, publicKey } = await window.aptos.connect();
    setAddress(address);
  }
  
  React.useEffect(() => {
     init();
  }, []);

  return (
    <div className="App">
      <p>Account Address: <code>{ address }</code></p>
    </div>
  );
}

export default App;

Refresh the page and you will see your account address.

Add some CSS
Next, replace the contents of src/App.css:

a, input, textarea {
  display: block;
}

textarea {
  border: 0;
  min-height: 50vh;
  outline: 0;
  padding: 0;
  width: 100%;
}

Step 3: Use the SDK to get data from the blockchain
The Wallet is now integrated with our dapp. Next, we will integrate the Aptos SDK to get data from the blockchain. We will use the Aptos SDK to retrieve information about our account and display that information on the page.

Add the aptos dependency to package.json
First, add the SDK to the project's dependencies:

npm install --save aptos

You will now see "aptos": "^1.3.15" (or similar) in your package.json.

Create an AptosClient
Now we can import the SDK and create an AptosClient to interact with the blockchain (technically it interacts with the REST API, which interacts with the blockchain).

As our wallet account is on devnet, we will set up the AptosClient to interact with devnet as well. Add the following to src/App.tsx:

import { Types, AptosClient } from 'aptos';

// Create an AptosClient to interact with devnet.
const client = new AptosClient('https://fullnode.devnet.aptoslabs.com/v1');

function App() {
  // ...

  // Use the AptosClient to retrieve details about the account.
  const [account, setAccount] = React.useState<Types.AccountData | null>(null);
  React.useEffect(() => {
    if (!address) return;
    client.getAccount(address).then(setAccount);
  }, [address]);

  return (
    <div className="App">
      <p>Account Address: <code>{ address }</code></p>
      <p>Sequence Number: <code>{ account?.sequence_number }</code></p>
    </div>
  );
}

Now, in addition to displaying the account address, the app will also display the account's sequence_number. This sequence_number represents the next transaction sequence number to prevent replay attacks of transactions. You will see this number increasing as you make transactions with the account.

TIP
If the account you're using for this application doesn't exist on-chain, you will not see a sequence number. You'll need to create the account first via a faucet.

Step 4: Publish a Move module
Our dapp is now set up to read from the blockchain. The next step is to write to the blockchain. To do so, we will publish a Move module to our account.

The Move module provides a location for this data to be stored. Specifically, we will use the hello_blockchain module from Your First Move Module, which provides a resource called MessageHolder that holds a string (called message).

Publish the `hello_blockchain` module with the Aptos CLI
Publish the `hello_blockchain` module with the TS SDK
Add module publishing instructions to the dapp
As a convenience to the users, we can have the app display the aptos move publish command if the module does not exist. To do so, we will use the Aptos SDK to retrieve the account modules and look for one where module.abi.name equals "message" (i.e., the "name": "message" we saw in the Aptos Explorer).

Update src/App.tsx:

function App() {
  // ...

  // Check for the module; show publish instructions if not present.
  const [modules, setModules] = React.useState<Types.MoveModuleBytecode[]>([]);
  React.useEffect(() => {
    if (!address) return;
    client.getAccountModules(address).then(setModules);
  }, [address]);

  const hasModule = modules.some((m) => m.abi?.name === 'message');
  const publishInstructions = (
    <pre>
      Run this command to publish the module:
      <br />
      aptos move publish --package-dir /path/to/hello_blockchain/
      --named-addresses hello_blockchain={address}
    </pre>
  );

  return (
    <div className="App">
      // ...
      {!hasModule && publishInstructions}
    </div>
  );
}

New users will be able to use this command to create a page for their account.

In this step, we can also hide the Publish Package button when the module does exist. Update the button on the src/App.tsx with:

function App() {
  // ...

  return (
    <div className="App">
      // ...
      {!hasModule && <button onClick={onPublishModule} disabled={isPublishing}>
          Publish Package
        </button>}
    </div>
  );
}

Step 5: Write a message on the blockchain
Now that the module has been published, we are ready to use it to write a message on the blockchain. For this step we will use the set_message function exposed by the module.

A transaction that calls the set_message function
The signature for set_message looks like this:

public(script) fun set_message(account: signer, message_bytes: vector<u8>)

To call this function, we need to use the window.aptos API provided by the wallet to submit a transaction. Specifically, we will create a entry_function_payload transaction that looks like this:

{
  type: "entry_function_payload",
  function: "<address>::message::set_message",
  arguments: ["Message to store"],
  type_arguments: []
}

There is no need to provide the account: signer argument. Aptos provides it automatically.

However, we do need to specify the message argument: this is the "Message to store" in the transaction.

Use the window.aptos API to submit the set_message transaction
Now that we understand how to use a transaction to call the set_message function, next we call this function from our app using window.aptos.signAndSubmitTransaction().

We will add:

A <textarea> where the user can input a message, and
A <button> that calls the set_message function with the contents of the <textarea>.
Update src/App.tsx:

function App() {
  // ...

  // Call set_message with the textarea value on submit.
  const ref = React.createRef<HTMLTextAreaElement>();
  const [isSaving, setIsSaving] = React.useState(false);
  const handleSubmit = async (e: any) => {
    e.preventDefault();
    if (!ref.current) return;

    const message = ref.current.value;
    const transaction = {
      type: "entry_function_payload",
      function: `${address}::message::set_message`,
      arguments: [message],
      type_arguments: [],
    };

    try {
      setIsSaving(true);
      await window.aptos.signAndSubmitTransaction(transaction);
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="App">
      {hasModule ? (
        <form onSubmit={handleSubmit}>
          <p>On-chain message</p>
          <textarea ref={ref} />
          <input disabled={isSaving} type="submit" />
        </form>
      ) : publishInstructions}
    </div>
  );
}


To test it:

Type something in the <textarea> and submit the form.
Find your account in the Aptos Explorer and you will now see a MessageHolder resource under Account Resources with the message you wrote.
If you don't see it, try a shorter message. Long messages may cause the transaction to fail because longer messages take more gas.

Step 6: Display the message in the dapp
Now that the MessageHolder resource has been created, we can use the Aptos SDK to retrieve it and display the message.

Get the wallet account's message
To retrieve the message, we will:

First use AptosClient.getAccountResources() function to fetch the account's resources and store them in state.

Then we will look for one whose type is MessageHolder. The full type is $address::message::MessageHolder as it is part of the $address::message module.

In our example it is:

 0x5af503b5c379bd69f46184304975e1ef1fa57f422dd193cdad67dc139d532481::message::MessageHolder

We will use this for the initial value of the <textarea>.

Update src/App.tsx:

function App() {
  // ...

  // Get the message from account resources.
  const [resources, setResources] = React.useState<Types.MoveResource[]>([]);
  React.useEffect(() => {
    if (!address) return;
    client.getAccountResources(address).then(setResources);
  }, [address]);
  const resourceType = `${address}::message::MessageHolder`;
  const resource = resources.find((r) => r.type === resourceType);
  const data = resource?.data as {message: string} | undefined;
  const message = data?.message;

  return (
    // ...
          <textarea defaultValue={message} />
    // ...
  );
}

To test it:

Refresh the page and you will see the message you wrote earlier.
Change the text, submit the form, and refresh the page again. You will see that the contents have been updated with your new message.
This confirms that you are reading and writing messages on the Aptos blockchain.

Display messages from other accounts
So far, we have built a "single-player" dapp where you can read and write a message on your own account. Next, we will make it possible for other people to read messages, including people who do not have the Aptos Wallet installed.

We will set it up so that going to the URL /<account address> displays the message stored at <account address> (if it exists).

If the app is loaded at /<account address>, we will also disable editing.

If editing is enabled, we will show a "Get public URL" link so you can share your message.

Update src/App.tsx:

function App() {
  // Retrieve aptos.account on initial render and store it.
  const urlAddress = window.location.pathname.slice(1);
  const isEditable = !urlAddress;
  const [address, setAddress] = React.useState<string | null>(null);
  React.useEffect(() => {
    if (urlAddress) {
      setAddress(urlAddress);
    } else {
      window.aptos.account().then((data : {address: string}) => setAddress(data.address));
    }
  }, [urlAddress]);

  // ...

  return (
    <div className="App">
      {hasModule ? (
        <form onSubmit={handleSubmit}>
          <p>On-chain message</p>
          <textarea ref={ref} defaultValue={message} readOnly={!isEditable} />
          {isEditable && (<input disabled={isSaving} type="submit" />)}
          {isEditable && (<a href={address!}>Get public URL</a>)}
        </form>
      ) : publishInstructions}
    </div>
  );
}

This concludes the tutorial.

Supporting documentation
Aptos CLI
TypeScript SDK
Wallet Standard

Your First Multisig
This tutorial introduces assorted K-of-N multi-signer authentication operations and supplements content from the following tutorials:

Your First Transaction
Your First Coin
Your First Move Module
TIP
Try out the above tutorials (which include dependency installations) before moving on to multisig operations.

Step 1: Pick an SDK
This tutorial, a community contribution, was created for the Python SDK.

Other developers are invited to add support for the TypeScript SDK, Rust SDK, and Unity SDK!

Step 2: Start the example
Navigate to the Python SDK directory:

cd <aptos-core-parent-directory>/aptos-core/ecosystem/python/sdk/

Run the multisig.py example:

poetry run python -m examples.multisig

TIP
This example uses the Aptos devnet, which has historically been reset each Thursday. Make sure devnet is live when you try running the example!

Step 3: Generate single signer accounts
First, we will generate single signer accounts for Alice, Bob, and Chad:

multisig.py snippet
alice = Account.generate()
bob = Account.generate()
chad = Account.generate()

print("\n=== Account addresses ===")
print(f"Alice: {alice.address()}")
print(f"Bob:   {bob.address()}")
print(f"Chad:  {chad.address()}")

print("\n=== Authentication keys ===")
print(f"Alice: {alice.auth_key()}")
print(f"Bob:   {bob.auth_key()}")
print(f"Chad:  {chad.auth_key()}")

print("\n=== Public keys ===")
print(f"Alice: {alice.public_key()}")
print(f"Bob:   {bob.public_key()}")
print(f"Chad:  {chad.public_key()}")  

Fresh accounts are generated for each example run, but the output should resemble:

Output
=== Account addresses ===
Alice: 0x93c1b7298d53dd0d517f503f2d3188fc62f6812ab94a412a955720c976fecf96
Bob:   0x85eb913e58d0885f6a966d98c76e4d00714cf6627f8db5903e1cd38cc86d1ce0
Chad:  0x14cf8dc376878ac268f2efc7ba65a2ee0ac13ceb43338b6106dd88d8d23e087a

=== Authentication keys ===
Alice: 0x93c1b7298d53dd0d517f503f2d3188fc62f6812ab94a412a955720c976fecf96
Bob:   0x85eb913e58d0885f6a966d98c76e4d00714cf6627f8db5903e1cd38cc86d1ce0
Chad:  0x14cf8dc376878ac268f2efc7ba65a2ee0ac13ceb43338b6106dd88d8d23e087a

=== Public keys ===
Alice: 0x3f23f869632aaa4378f3d68560e08d18b1fc2e80f91d6f9d1b39d720b0ef7a3f
Bob:   0xcf21e85337a313bdac33d068960a3e52d22ce0e6190e9acc03a1c9930e1eaf3e
Chad:  0xa1a2aef8525eb20655387d3ed50b9a3ea1531ef6117f579d0da4bcf5a2e1f76d

For each user, note the account address and authentication key are identical, but the public key is different.

Step 4: Generate a multisig account
Next generate a K-of-N multi-signer public key and account address for a multisig account requiring two of the three signatures:

multisig.py snippet
threshold = 2

multisig_public_key = MultiPublicKey(
    [alice.public_key(), bob.public_key(), chad.public_key()], threshold
)

multisig_address = AccountAddress.from_multi_ed25519(multisig_public_key)

print("\n=== 2-of-3 Multisig account ===")
print(f"Account public key: {multisig_public_key}")
print(f"Account address:    {multisig_address}")  

The multisig account address depends on the public keys of the single signers. (Hence, it will be different for each example.) But the output should resemble:

Output
=== 2-of-3 Multisig account ===
Account public key: 2-of-3 Multi-Ed25519 public key
Account address:    0x08cac3b7b7ce4fbc5b18bc039279d7854e4c898cbf82518ac2650b565ad4d364

Step 5: Fund all accounts
Next fund all accounts:

multisig.py snippet
print("\n=== Funding accounts ===")
alice_start = 10_000_000
bob_start = 20_000_000
chad_start = 30_000_000
multisig_start = 40_000_000

alice_fund = faucet_client.fund_account(alice.address(), alice_start)
bob_fund = faucet_client.fund_account(bob.address(), bob_start)
chad_fund = faucet_client.fund_account(chad.address(), chad_start)
multisig_fund = faucet_client.fund_account(multisig_address, multisig_start)
await asyncio.gather(*[alice_fund, bob_fund, chad_fund, multisig_fund])

alice_balance = rest_client.account_balance(alice.address())
bob_balance = rest_client.account_balance(bob.address())
chad_balance = rest_client.account_balance(chad.address())
multisig_balance = rest_client.account_balance(multisig_address)
[alice_balance, bob_balance, chad_balance, multisig_balance] = await asyncio.gather(
    *[alice_balance, bob_balance, chad_balance, multisig_balance]
)

print(f"Alice's balance:  {alice_balance}")
print(f"Bob's balance:    {bob_balance}")
print(f"Chad's balance:   {chad_balance}")
print(f"Multisig balance: {multisig_balance}")  

Output
=== Funding accounts ===
Alice's balance:  10000000
Bob's balance:    20000000
Chad's balance:   30000000
Multisig balance: 40000000

Step 6: Send coins from the multisig
This transaction will send 100 octas from the multisig account to Chad's account. Since it is a two-of-three multisig account, signatures are required from only two individual signers.

Step 6.1: Gather individual signatures
First generate a raw transaction, signed by Alice and Bob, but not by Chad.

multisig.py snippet
entry_function = EntryFunction.natural(
    module="0x1::coin",
    function="transfer",
    ty_args=[TypeTag(StructTag.from_str("0x1::aptos_coin::AptosCoin"))],
    args=[
        TransactionArgument(chad.address(), Serializer.struct),
        TransactionArgument(100, Serializer.u64),
    ],
)

chain_id = await rest_client.chain_id()
raw_transaction = RawTransaction(
    sender=multisig_address,
    sequence_number=0,
    payload=TransactionPayload(entry_function),
    max_gas_amount=rest_client.client_config.max_gas_amount,
    gas_unit_price=rest_client.client_config.gas_unit_price,
    expiration_timestamps_secs=(
        int(time.time()) + rest_client.client_config.expiration_ttl
    ),
    chain_id=chain_id,
)

alice_signature = alice.sign(raw_transaction.keyed())
bob_signature = bob.sign(raw_transaction.keyed())

assert raw_transaction.verify(alice.public_key(), alice_signature)
assert raw_transaction.verify(bob.public_key(), bob_signature)

print("\n=== Individual signatures ===")
print(f"Alice: {alice_signature}")
print(f"Bob:   {bob_signature}")  

Again, signatures vary for each example run:

Output
=== Individual signatures ===
Alice: 0x41b9dd65857df2d8d8fba251336357456cc9f17974de93292c13226f560102eac1e70ddc7809a98cd54ddee9b79853e8bf7d18cfef23458f23e3a335c3189e0d
Bob:   0x6305101f8f3ad5a75254a8fa74b0d9866756abbf359f9e4f2b54247917caf8c52798a36c5a81c77505ebc1dc9b80f2643e8fcc056bcc4f795e80b229fa41e509


Step 6.2: Submit the multisig transaction
Next generate a multisig authenticator and submit the transaction:

multisig.py snippet
sig_map = [  # Map from signatory public key to signature.
    (alice.public_key(), alice_signature),
    (bob.public_key(), bob_signature),
]

multisig_signature = MultiSignature(multisig_public_key, sig_map)

authenticator = Authenticator(
    MultiEd25519Authenticator(multisig_public_key, multisig_signature)
)

signed_transaction = SignedTransaction(raw_transaction, authenticator)

print("\n=== Submitting transfer transaction ===")

tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)
await rest_client.wait_for_transaction(tx_hash)
print(f"Transaction hash: {tx_hash}")  

Output
=== Submitting transfer transaction ===
Transaction hash: 0x3ff2a848bf6145e6df3abb3ccb8b94fefd07ac16b4acb0c694fa7fa30b771f8c

Step 6.3: Check balances
Check the new account balances:

multisig.py snippet
print("\n=== New account balances===")

alice_balance = rest_client.account_balance(alice.address())
bob_balance = rest_client.account_balance(bob.address())
chad_balance = rest_client.account_balance(chad.address())
multisig_balance = rest_client.account_balance(multisig_address)
[alice_balance, bob_balance, chad_balance, multisig_balance] = await asyncio.gather(
    *[alice_balance, bob_balance, chad_balance, multisig_balance]
)

print(f"Alice's balance:  {alice_balance}")
print(f"Bob's balance:    {bob_balance}")
print(f"Chad's balance:   {chad_balance}")
print(f"Multisig balance: {multisig_balance}")  

Output
=== New account balances===
Alice's balance:  10000000
Bob's balance:    20000000
Chad's balance:   30000100
Multisig balance: 39999300

Note that even though Alice and Bob signed the transaction, their account balances have not changed. Chad, however, has received 100 octas from the multisig account, which assumed the gas costs of the transaction and thus has had more than 100 octas deducted.

Step 7: Create a vanity address multisig
In this section, a fourth user named Deedee will generate a vanity address, then rotate her account to the two-of-three multisig.

Step 7.1 Generate a vanity address
A fourth user, Deedee, wants her account address to start with 0xdd.., so she generates random accounts until she finds one with a matching account address:

multisig.py snippet
print("\n=== Funding vanity address ===")

deedee = Account.generate()

while str(deedee.address())[2:4] != "dd":
    deedee = Account.generate()

print(f"Deedee's address:    {deedee.address()}")
print(f"Deedee's public key: {deedee.public_key()}")

deedee_start = 50_000_000

await faucet_client.fund_account(deedee.address(), deedee_start)
deedee_balance = await rest_client.account_balance(deedee.address())
print(f"Deedee's balance:    {deedee_balance}")  

Output
=== Funding vanity address ===
Deedee's address:    0xdd86860ae7f77f58d08188e1c39fbc6a2f7cec782f09f6767f8367d84357ed57
Deedee's public key: 0xdbf02311c45903f0217e9ab76ca64007c2876363118bb422922410d4cfe9964c
Deedee's balance:    50000000

Step 7.2 Sign a rotation proof challenge
Deedee and the two-of-three multisig must both sign a RotationProofChallenge, yielding two signatures. Deedee's signature, cap_rotate_key, verifies that she approves of the authentication key rotation. The multisig signature, cap_update_table, verifies that the multisig approves of the authentication key rotation. Here, Bob and Chad provide individual signatures for the multisig:

multisig.py snippet
print("\n=== Signing rotation proof challenge ===")

rotation_proof_challenge = RotationProofChallenge(
    sequence_number=0,
    originator=deedee.address(),
    current_auth_key=deedee.address(),
    new_public_key=multisig_public_key.to_bytes(),
)

serializer = Serializer()
rotation_proof_challenge.serialize(serializer)
rotation_proof_challenge_bcs = serializer.output()

cap_rotate_key = deedee.sign(rotation_proof_challenge_bcs).data()

cap_update_table = MultiSignature(
    multisig_public_key,
    [
        (bob.public_key(), bob.sign(rotation_proof_challenge_bcs)),
        (chad.public_key(), chad.sign(rotation_proof_challenge_bcs)),
    ],
).to_bytes()

cap_rotate_key_hex = f"0x{cap_rotate_key.hex()}"
cap_update_table_hex = f"0x{cap_update_table.hex()}"

print(f"cap_rotate_key:   {cap_rotate_key_hex}")
print(f"cap_update_table: {cap_update_table_hex}")  

Output
=== Signing rotation proof challenge ===
cap_rotate_key:   0x3b2906df78bb79f210051e910985c358572c2ec7cdd03f688480fb6adf8d538df48a52787d5651d85f2959dcca88d58da49709c9c0dc9c3c58b67169ec1e1c01
cap_update_table: 0x965fd11d7afe14396e5af40b8ffb78e6eb6f7caa1f1b1d8c7b819fdd6045864e70258788ec1670a3989c85f8cc604f4b54e43e1ce173a59aa0a6f7cf124fd902dcbb2ad53467d05c144260b2be1814777c082d8db437698b00e6a2109a015a565ff5783e827a21a4c07ae332b56398b69dfdbcc08b8ad5585dc1ac649b74730760000000


Step 7.3 Rotate the authentication key
Now that the relevant signatures have been gathered, the authentication key rotation transaction can be submitted. After it executes, the rotated authentication key matches the address of the first multisig account (the one that sent octas to Chad):

multisig.py snippet
print("\n=== Submitting authentication key rotation transaction ===")

from_scheme = Authenticator.ED25519
from_public_key_bytes = deedee.public_key().key.encode()
to_scheme = Authenticator.MULTI_ED25519
to_public_key_bytes = multisig_public_key.to_bytes()

entry_function = EntryFunction.natural(
    module="0x1::account",
    function="rotate_authentication_key",
    ty_args=[],
    args=[
        TransactionArgument(from_scheme, Serializer.u8),
        TransactionArgument(from_public_key_bytes, Serializer.to_bytes),
        TransactionArgument(to_scheme, Serializer.u8),
        TransactionArgument(to_public_key_bytes, Serializer.to_bytes),
        TransactionArgument(cap_rotate_key, Serializer.to_bytes),
        TransactionArgument(cap_update_table, Serializer.to_bytes),
    ],
)

signed_transaction = await rest_client.create_bcs_signed_transaction(
    deedee, TransactionPayload(entry_function)
)

account_data = await rest_client.account(deedee.address())
print(f"Auth key pre-rotation: {account_data['authentication_key']}")

tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)
await rest_client.wait_for_transaction(tx_hash)
print(f"Transaction hash:      {tx_hash}")

account_data = await rest_client.account(deedee.address())
print(f"New auth key:          {account_data['authentication_key']}")
print(f"1st multisig address:  {multisig_address}")  

Output
=== Submitting authentication key rotation transaction ===
Auth key pre-rotation: 0xdd86860ae7f77f58d08188e1c39fbc6a2f7cec782f09f6767f8367d84357ed57
Transaction hash:      0x57c66089a1b81e2895a2d6919ab19eb90c4d3c3cbe9fecab8169eaeedff2c6e6
New auth key:          0x08cac3b7b7ce4fbc5b18bc039279d7854e4c898cbf82518ac2650b565ad4d364
1st multisig address:  0x08cac3b7b7ce4fbc5b18bc039279d7854e4c898cbf82518ac2650b565ad4d364

In other words, Deedee generated an account with a vanity address so that Alice, Bob, and Chad could use it as a multisig account. Then Deedee and the Alice/Bob/Chad group (under the authority of Bob and Chad) approved to rotate the vanity account's authentication key to the authentication key of the first multisig account.

Step 8: Perform Move package governance
In this section, the multisig vanity account will publish a simple package, upgrade it, then invoke a Move script.

Move source code for this section is found in the upgrade_and_govern directory.

Step 8.1: Review genesis package
The UpgradeAndGovern genesis package (version 1.0.0) contains a simple .toml manifest and a single Move source file:

Move.toml
[package]
name = 'UpgradeAndGovern'
version = '1.0.0'

[addresses]
upgrade_and_govern = '_'

[dependencies.AptosFramework]
local = '../../../framework/aptos-framework' 

parameters.move
/// Mock on-chain governance parameters.
module upgrade_and_govern::parameters {

    struct GovernanceParameters has key {
        parameter_1: u64,
        parameter_2: u64
    }

    const GENESIS_PARAMETER_1: u64 = 123;
    const GENESIS_PARAMETER_2: u64 = 456;

    fun init_module(
        upgrade_and_govern: &signer
    ) {
        let governance_parameters = GovernanceParameters{
            parameter_1: GENESIS_PARAMETER_1,
            parameter_2: GENESIS_PARAMETER_2};
        move_to<GovernanceParameters>(
            upgrade_and_govern, governance_parameters);
    }

    public fun get_parameters():
    (u64, u64)
    acquires GovernanceParameters {
        let governance_parameters_ref =
            borrow_global<GovernanceParameters>(@upgrade_and_govern);
        (governance_parameters_ref.parameter_1,
         governance_parameters_ref.parameter_2)
    }

} 

As soon as the package is published, a GovernanceParameters resource is moved to the upgrade_and_govern package account with the values specified by GENESIS_PARAMETER_1 and GENESIS_PARAMETER_2. Then, the get_parameters() function can be used to look up the governance parameters, but note that in this version there is no setter function. The setter function will be added later.

Step 8.2: Publish genesis package
Here, Alice and Chad will sign off on the publication transaction.

All compilation and publication operations are handled via the ongoing Python script:

multisig.py snippet
print("\n=== Genesis publication ===")

packages_dir = "../../../aptos-move/move-examples/upgrade_and_govern/"

command = (
    f"aptos move compile "
    f"--save-metadata "
    f"--package-dir {packages_dir}genesis "
    f"--named-addresses upgrade_and_govern={str(deedee.address())}"
)

print(f"Running aptos CLI command: {command}\n")
subprocess.run(command.split(), stdout=subprocess.PIPE)

build_path = f"{packages_dir}genesis/build/UpgradeAndGovern/"

with open(f"{build_path}package-metadata.bcs", "rb") as f:
    package_metadata = f.read()

with open(f"{build_path}bytecode_modules/parameters.mv", "rb") as f:
    parameters_module = f.read()

modules_serializer = Serializer.sequence_serializer(Serializer.to_bytes)

payload = EntryFunction.natural(
    module="0x1::code",
    function="publish_package_txn",
    ty_args=[],
    args=[
        TransactionArgument(package_metadata, Serializer.to_bytes),
        TransactionArgument([parameters_module], modules_serializer),
    ],
)

raw_transaction = RawTransaction(
    sender=deedee.address(),
    sequence_number=1,
    payload=TransactionPayload(payload),
    max_gas_amount=rest_client.client_config.max_gas_amount,
    gas_unit_price=rest_client.client_config.gas_unit_price,
    expiration_timestamps_secs=(
        int(time.time()) + rest_client.client_config.expiration_ttl
    ),
    chain_id=chain_id,
)

alice_signature = alice.sign(raw_transaction.keyed())
chad_signature = chad.sign(raw_transaction.keyed())

sig_map = [  # Map from signatory public key to signature.
    (alice.public_key(), alice_signature),
    (chad.public_key(), chad_signature),
]

multisig_signature = MultiSignature(multisig_public_key, sig_map)

authenticator = Authenticator(
    MultiEd25519Authenticator(multisig_public_key, multisig_signature)
)

signed_transaction = SignedTransaction(raw_transaction, authenticator)

tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)
await rest_client.wait_for_transaction(tx_hash)
print(f"\nTransaction hash: {tx_hash}")

registry = await rest_client.account_resource(
    deedee.address(), "0x1::code::PackageRegistry"
)

package_name = registry["data"]["packages"][0]["name"]
n_upgrades = registry["data"]["packages"][0]["upgrade_number"]

print(f"Package name from on-chain registry: {package_name}")
print(f"On-chain upgrade number: {n_upgrades}")  

Output
=== Genesis publication ===
Running aptos CLI command: aptos move compile --save-metadata --package-dir ../../../../aptos-move/move-examples/upgrade_and_govern/genesis --named-addresses upgrade_and_govern=0xdd86860ae7f77f58d08188e1c39fbc6a2f7cec782f09f6767f8367d84357ed57

Compiling, may take a little while to download git dependencies...
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING UpgradeAndGovern

Transaction hash: 0x3c65c681194d6c64d73dc5d0cbcbad62e99a997b8600b8edad6847285e580c13
Package name from on-chain registry: UpgradeAndGovern
On-chain upgrade number: 0


Step 8.3: Review package upgrades
The UpgradeAndGovern upgrade package adds the following parameter setter functionality at the end of parameters.move:

parameters.move
    use std::signer::address_of;

    const E_INVALID_AUTHORITY: u64 = 0;

    public entry fun set_parameters(
        upgrade_and_govern: &signer,
        parameter_1: u64,
        parameter_2: u64
    ) acquires GovernanceParameters {
        assert!(address_of(upgrade_and_govern) == @upgrade_and_govern,
                E_INVALID_AUTHORITY);
        let governance_parameters_ref_mut =
            borrow_global_mut<GovernanceParameters>(@upgrade_and_govern);
        governance_parameters_ref_mut.parameter_1 = parameter_1;
        governance_parameters_ref_mut.parameter_2 = parameter_2;
    }

} 

Here, the account that the package is published under, upgrade_and_govern, has the authority to change the GovernanceParameter values from the genesis values to the new parameter_1 and parameter_2 values.

There is also a new module, transfer.move:

transfer.move
/// Mock coin transfer module that invokes governance parameters.
module upgrade_and_govern::transfer {

    use aptos_framework::aptos_coin::AptosCoin;
    use aptos_framework::coin;
    use upgrade_and_govern::parameters;

    public entry fun transfer_octas(
        from: &signer,
        to_1: address,
        to_2: address
    ) {
        let (amount_1, amount_2) = parameters::get_parameters();
        coin::transfer<AptosCoin>(from, to_1, amount_1);
        coin::transfer<AptosCoin>(from, to_2, amount_2);
    }

} 

This module simply looks up the GovernanceParameter values, and treats them as the amount of octas to send to two recipients.

Lastly, the manifest has been updated with the new version number 1.1.0:

Move.toml
[package]
name = 'UpgradeAndGovern'
version = '1.1.0'

[addresses]
upgrade_and_govern = '_'

[dependencies.AptosFramework]
local = '../../../framework/aptos-framework' 

Step 8.4: Upgrade the package
Alice, Bob, and Chad will all sign off on this publication transaction, which results in an upgrade. This process is almost identical to that of the genesis publication, with the new transfer module listed after the parameters module:

multisig.py snippet
print("\n=== Upgrade publication ===")

command = (
    f"aptos move compile "
    f"--save-metadata "
    f"--package-dir {packages_dir}upgrade "
    f"--named-addresses upgrade_and_govern={str(deedee.address())}"
)

print(f"Running aptos CLI command: {command}\n")
subprocess.run(command.split(), stdout=subprocess.PIPE)

build_path = f"{packages_dir}upgrade/build/UpgradeAndGovern/"

with open(f"{build_path}package-metadata.bcs", "rb") as f:
    package_metadata = f.read()

with open(f"{build_path}bytecode_modules/parameters.mv", "rb") as f:
    parameters_module = f.read()

with open(f"{build_path}bytecode_modules/transfer.mv", "rb") as f:
    transfer_module = f.read()

payload = EntryFunction.natural(
    module="0x1::code",
    function="publish_package_txn",
    ty_args=[],
    args=[
        TransactionArgument(package_metadata, Serializer.to_bytes),
        TransactionArgument(  # Transfer module listed second.
            [parameters_module, transfer_module],
            Serializer.sequence_serializer(Serializer.to_bytes),
        ),
    ],
)

raw_transaction = RawTransaction(
    sender=deedee.address(),
    sequence_number=2,
    payload=TransactionPayload(payload),
    max_gas_amount=rest_client.client_config.max_gas_amount,
    gas_unit_price=rest_client.client_config.gas_unit_price,
    expiration_timestamps_secs=(
        int(time.time()) + rest_client.client_config.expiration_ttl
    ),
    chain_id=chain_id,
)

alice_signature = alice.sign(raw_transaction.keyed())
bob_signature = bob.sign(raw_transaction.keyed())
chad_signature = chad.sign(raw_transaction.keyed())

sig_map = [  # Map from signatory public key to signature.
    (alice.public_key(), alice_signature),
    (bob.public_key(), bob_signature),
    (chad.public_key(), chad_signature),
]

multisig_signature = MultiSignature(multisig_public_key, sig_map)

authenticator = Authenticator(
    MultiEd25519Authenticator(multisig_public_key, multisig_signature)
)

signed_transaction = SignedTransaction(raw_transaction, authenticator)

tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)
await rest_client.wait_for_transaction(tx_hash)
print(f"\nTransaction hash: {tx_hash}")

registry = await rest_client.account_resource(
    deedee.address(), "0x1::code::PackageRegistry"
)

n_upgrades = registry["data"]["packages"][0]["upgrade_number"]

print(f"On-chain upgrade number: {n_upgrades}")  

TIP
Modules that use other modules must be listed after the modules they use.

Output
=== Upgrade publication ===
Running aptos CLI command: aptos move compile --save-metadata --package-dir ../../../../aptos-move/move-examples/upgrade_and_govern/upgrade --named-addresses upgrade_and_govern=0xdd86860ae7f77f58d08188e1c39fbc6a2f7cec782f09f6767f8367d84357ed57

Compiling, may take a little while to download git dependencies...
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING UpgradeAndGovern

Transaction hash: 0x0f0ea3bb7271ddeaceac5b49ff5503d6c652d4746c1510e47665ceee5a89aaf0
On-chain upgrade number: 1


Note that the on-chain upgrade number has been incremented by 1.

Step 8.6: Review the governance script
The UpgradeAndGovern upgrade package also includes a Move script at set_and_transfer.move:

set_and_transfer.move
script {
    use upgrade_and_govern::parameters;
    use upgrade_and_govern::transfer;

    const PARAMETER_1: u64 = 300;
    const PARAMETER_2: u64 = 200;

    fun set_and_transfer(
        upgrade_and_govern: &signer,
        to_1: address,
        to_2: address
    ) {
        parameters::set_parameters(
            upgrade_and_govern, PARAMETER_1, PARAMETER_2);
        transfer::transfer_octas(upgrade_and_govern, to_1, to_2);
    }
} 

This script calls the governance parameter setter using hard-coded values defined at the top of the script, then calls the octa transfer function. The script accepts as arguments the signature of the account hosting the package, as well as two target addresses for the transfer operation.

Note that both functions in the script are public entry fun functions, which means that everything achieved in the script could be performed without a script. However, a non-script approach would require two transactions instead of just one, and would complicate the signature aggregation process: in practical terms, Alice, Bob, and/or Chad would likely have to send single-signer transaction signatures around through off-chain communication channels, and a scribe for the group would then have to submit a multisig Authenticator (for each public entry fun call). Hence in a non-script approach, extra operational complexity can quickly introduce opportunities for consensus failure.

A Move script, by contrast, collapses multiple governance function calls into a single transaction; and moreover, Move scripts can be published in a public forum like GitHub so that all signatories can review the actual function calls before they sign the script.

Step 8.5: Execute the governance script
Alice and Bob sign off on the Move script, which sends coins from the vanity multisig account to their personal accounts. Here, the amounts sent to each account are specified in the hard-coded values from the script.

multisig.py snippet
print("\n=== Invoking Move script ===")

with open(f"{build_path}bytecode_scripts/set_and_transfer.mv", "rb") as f:
    script_code = f.read()

payload = Script(
    code=script_code,
    ty_args=[],
    args=[
        ScriptArgument(ScriptArgument.ADDRESS, alice.address()),
        ScriptArgument(ScriptArgument.ADDRESS, bob.address()),
    ],
)

raw_transaction = RawTransaction(
    sender=deedee.address(),
    sequence_number=3,
    payload=TransactionPayload(payload),
    max_gas_amount=rest_client.client_config.max_gas_amount,
    gas_unit_price=rest_client.client_config.gas_unit_price,
    expiration_timestamps_secs=(
        int(time.time()) + rest_client.client_config.expiration_ttl
    ),
    chain_id=chain_id,
)

alice_signature = alice.sign(raw_transaction.keyed())
bob_signature = bob.sign(raw_transaction.keyed())

sig_map = [  # Map from signatory public key to signature.
    (alice.public_key(), alice_signature),
    (bob.public_key(), bob_signature),
]

multisig_signature = MultiSignature(multisig_public_key, sig_map)

authenticator = Authenticator(
    MultiEd25519Authenticator(multisig_public_key, multisig_signature)
)

signed_transaction = SignedTransaction(raw_transaction, authenticator)

tx_hash = await rest_client.submit_bcs_transaction(signed_transaction)
await rest_client.wait_for_transaction(tx_hash)
print(f"Transaction hash: {tx_hash}")

alice_balance = rest_client.account_balance(alice.address())
bob_balance = rest_client.account_balance(bob.address())
chad_balance = rest_client.account_balance(chad.address())
multisig_balance = rest_client.account_balance(multisig_address)
[alice_balance, bob_balance, chad_balance, multisig_balance] = await asyncio.gather(
    *[alice_balance, bob_balance, chad_balance, multisig_balance]
)

print(f"Alice's balance:  {alice_balance}")
print(f"Bob's balance:    {bob_balance}")
print(f"Chad's balance:   {chad_balance}")
print(f"Multisig balance: {multisig_balance}")  

Output
=== Invoking Move script ===
Transaction hash: 0xd06de4bd9fb12a9f3cbd8ce1b9a9fd47ea2b923a8cfac21f9788869430e4149b
Alice's balance:  10000300
Bob's balance:    20000200
Chad's balance:   30000100

Congratulations on completing the tutorial on K-of-N multi-signer authentication operations!

Move on Aptos
The Aptos blockchain consists of validator nodes that run a consensus protocol. The consensus protocol agrees upon the ordering of transactions and their output when executed on the Move Virtual Machine (MoveVM). Each validator node translates transactions along with the current blockchain ledger state as input into the VM. The MoveVM processes this input to produce a changeset or storage delta as output. Once consensus agrees and commits to the output, it becomes publicly visible. In this guide, we will introduce you to core Move concepts and how they apply to developing on Aptos.

What is Move?
Move is a safe and secure programming language for Web3 that emphasizes scarcity and access control. Any assets in Move can be represented by or stored within resource. Scarcity is enforced by default as structs cannot be accidentally duplicated or dropped. Only structs that have explicitly been defined at the bytecode layer as copy can be duplicated and drop can be dropped, respectively.

Access control comes from both the notion of accounts as well as module access privileges. A module in Move may either be a library or a program that can create, store, or transfer assets. Move ensures that only public module functions may be accessed by other modules. Unless a struct has a public constructor, it can only be constructed within the module that defines it. Similarly, fields within a struct can only be accessed and mutated within its module that or via public accessors and setters. Furthermore, structs defined with key can be stored and read from global storage only within the module defines it. Structs with store can be stored within another store or key struct inside or outside the module that defines that struct.

In Move, a transaction's sender is represented by a signer, a verified owner of a specific account. The signer has the highest level of permission in Move and is the only entity capable of adding resources into an account. In addition, a module developer can require that a signer be present to access resources or modify assets stored within an account.

Comparison to other VMs
Aptos / Move	Solana / SeaLevel	EVM	Sui / Move
Data storage	Stored at a global address or within the owner's account	Stored within the owner's account associated with a program	Stored within the account associated with a smart contract	Stored at a global address
Parallelization	Capable of inferring parallelization at runtime within Aptos	Requires specifying all data accessed	Currently serial nothing in production	Requires specifying all data accessed
Transaction safety	Sequence number	Transaction uniqueness	nonces, similar to sequence numbers	Transaction uniqueness
Type safety	Module structs and generics	Program structs	Contract types	Module structs and generics
Function calling	Static dispatch	Static dispatch	Dynamic dispatch	Static dispatch
Authenticated Storage	Yes	No	Yes	No
Object accessibility	Guaranteed to be globally accessible	Not applicable	Not applicable	Can be hidden
Aptos Move features
Each deployment of the MoveVM has the ability to extend the core MoveVM with additional features via an adapter layer. Furthermore, MoveVM has a framework to support standard operations much like a computer has an operating system.

The Aptos Move adapter features include:

Move Objects that offer an extensible programming model for globally access to heterogeneous set of resources stored at a single address on-chain.
Cryptography primitives for building scalable, privacy-preserving dapps.
Resource accounts that offer programmable accounts on-chain, which can be useful for DAOs (decentralized autonomous organizations), shared accounts, or building complex applications on-chain.
Tables for storing key, value data within an account at scale.
Parallelism via Block-STM that enables concurrent execution of transactions without any input from the user.
The Aptos framework ships with many useful libraries:

A Token standard that makes it possible to create NFTs and other rich tokens without publishing a smart contract
A Coin standard that makes it possible to create type-safe Coins by publishing a trivial module
A staking and delegation framework
A type_of service to identify at run-time the address, module, and struct name of a given type
Multi-signer framework that allows multiple signer entities
A timestamp service that provides a monotonically increasing clock that maps to the actual current unixtime
With updates frequently.

More Resources
To start developing smart contracts on the Aptos blockchain, we recommend the following resources:

Aptos Move Examples
End-to-End Aptos Move Tests
Move language channel in Aptos Discord.
Aptos Move Framework.
There are several IDE plugins available for Aptos and the Move language:

Syntax highlighting for Visual Studio Code
Move language plugin for Jetbrains IDEs: Supports syntax highlighting, code navigation, renames, formatting, type checks and code generation.
Remix IDE Plugin: Offers a web-based development environment. It is a no-setup tool with a graphical interface for developing Move modules.
Use these external resources to learn about the Move programming language:

Teach yourself Move on Aptos.
Formal Verification, the Move Language, and the Move Prover
IMCODING Move Tutorials
Pontem Move Playground
Collection of nestable Move resources
Move-Lang tag on Stack Overflow

Resource Accounts
A resource account is a developer feature used to manage resources independent of an account managed by a user, specifically publishing modules and automatically signing for transactions. For example, a developer may use a resource account to manage an account for module publishing, say managing a contract. The contract itself does not require a signer post initialization. A resource account gives you the means for the module to provide a signer to other modules and sign transactions on behalf of the module.

Typically, a resource account is used for two main purposes:

Store and isolate resources; a module creates a resource account just to host specific resources.
Publish module as a standalone (resource) account, a building block in a decentralized design where no private keys can control the resource account. The ownership (SignerCap) can be kept in another module, such as governance.
Restrictions
In Aptos, a resource account is created based upon the SHA3-256 hash of the source's address and additional seed data. A resource account can be created only once; for a given source address and seed, there can be only one resource account. That is because the calculation of the resource account address is fully determined by the former.

An entity may call create_account in an attempt to claim an account ahead of the creation of a resource account. But if a resource account is found, Aptos will transition ownership of the account over to the resource account. This is done by validating that the account has yet to execute any transactions and that the Account::signer_capbility_offer::for is none. The probability of a collision where someone has legitimately produced a private key that maps to a resource account address is improbably low.

Setup
The easiest way to set up a resource account is by:

Using Aptos CLI: aptos account create-resource-account creates a resource account, and aptos move create-resource-account-and-publish-package creates a resource account and publishes the specified package under the resource account's address.
Writing custom smart contracts code: in the resource_account.move module, developers can find the resource account creation functions create_resource_account, create_resource_account_and_fund, and create_resource_account_and_publish_package. Developers can then call those functions to create resource accounts in their smart contracts.
Each of those options offers slightly different functionality:

create_resource_account - merely creates the resource account but doesn't fund it, retaining access to the resource account's signer until explicitly calling retrieve_resource_account_cap.
create_resource_account_and_fund - creates the resource account and funds it, retaining access to the resource account's signer until explicitly calling retrieve_resource_account_cap.
create_resource_account_and_publish_package - creates the resource account and results in loss of access to the resource account by design, because resource accounts are used to make contracts autonomous and immutable.
In this example, you will initialize the mint_nft module and retrieve the signer capability from both the resource account and module account. To do so, call create_resource_account_and_publish_package to publish the module under the resource account's address.

Initialize the module as shown in the minting.move example.
Call create_resource_account_and_publish_package to publish the module under the resource account's address, such as in the mint_nft.rs end-to-end example.
Retrieve the signer cap from the resource account + module account as shown in the minting.move example.
Note, if the above resource_account signer is not already set up as a resource account, retrieving the signer cap will fail. The source_addr field in the retrieve_resource_account_cap function refers to the address of the source account, or the account that creates the resource account.

For an example, see the SignerCapability employed by the mint_nft function in minting.move.

For more details, see the "resource account" references in resource_account.move and account.move.

Modules on Aptos
Aptos allows for permissionless publishing of modules within a package as well as upgrading those that have appropriate compatibility policy set.

A module contains several structs and functions, much like Rust.

During package publishing time, a few constraints are maintained:

Both Structs and public function signatures are published as immutable.
Only when a module is being published for the first time, and not during an upgrade, will the VM search for and execute an init_module(account: &signer) function. The signer of the account that is publishing the module is passed into the init_module function of the contract. This function must be private and not return any value.
init_module IS OPTIONAL
It is only necessary if you want to initialize data when publishing a module for the first time.

Move Scripts
This tutorial explains how to write and execute a Move script. You can use Move scripts to execute a series of commands across published Move module interfaces.

Example use case
The following example calls functions on the aptos_coin.move module to confirm the balance of the destination account is less than desired_balance, and if so, tops it up to desired_balance.

script {
    use std::signer;
    use aptos_framework::aptos_account;
    use aptos_framework::aptos_coin;
    use aptos_framework::coin;

    fun main(src: &signer, dest: address, desired_balance: u64) {
        let src_addr = signer::address_of(src);
        
        addr::my_module::do_nothing();

        let balance = coin::balance<aptos_coin::AptosCoin>(src_addr);
        if (balance < desired_balance) {
            aptos_account::transfer(src, dest, desired_balance - balance);
        };
    }
}

Execution
Now that you know what you would like to accomplish, you need to determine:

Where do I put these files?
What do I name them?
Do I need a Move.toml?
How do I run my script with the CLI?
Let us run through how to execute a Move script with a step-by-step example using the Aptos CLI.

Make a new directory for your work:

mkdir testing
cd testing

Set up the Aptos CLI and create an account:

aptos init --network devnet

You may reuse an existing private key (which looks like this: 0xbd944102bf5b5dfafa7fe865d8fa719da6a1f0eafa3cd600f93385482d2c37a4), or it can generate a new one for you, as part of setting up your account. Let's say your account looks like the example below:

---
profiles:
  default:
    private_key: "0xbd944102bf5b5dfafa7fe865d8fa719da6a1f0eafa3cd600f93385482d2c37a4"
    public_key: "0x47673ec83bb254cc9a8bfdb31846daacd0c96fe41f81855462f5fc5306312b1b"
    account: cb265645385819f3dbe71aac266e319e7f77aed252cacf2930b68102828bf615
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"

From this same directory, initialize a new Move project:

aptos move init --name run_script

Create a my_script.move file containing the example script above in a sources/ subdirectory of your testing/ directory. Also, create a my_module.move file as seen in the example below:

module addr::my_module {
    public entry fun do_nothing() { }
}

This results in the following file structure:

testing/
   Move.toml
   sources/
      my_script.move
      my_module.move

Compile the script:

$ aptos move compile --named-addresses addr=cb265645385819f3dbe71aac266e319e7f77aed252cacf2930b68102828bf615
Compiling, may take a little while to download git dependencies...
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING run_script
{
  "Result": [
    "cb265645385819f3dbe71aac266e319e7f77aed252cacf2930b68102828bf615::my_module"
  ]
}


Note how we use the --named-addresses argument. This is necessary because in the code we refer to this named address called addr. The compiler needs to know what this refers to. Instead of using this CLI argument, you could put something like this in your Move.toml:

[addresses]
addr = "cb265645385819f3dbe71aac266e319e7f77aed252cacf2930b68102828bf615"

Run the compiled script:

$ aptos move run-script --compiled-script-path build/my_script/bytecode_scripts/main.mv --args address:b078d693856a65401d492f99ca0d6a29a0c5c0e371bc2521570a86e40d95f823 --args u64:5
Do you want to submit a transaction for a range of [17000 - 25500] Octas at a gas unit price of 100 Octas? [yes/no] >
yes
{
  "Result": {
    "transaction_hash": "0xa6ca6275c73f82638b88a830015ab81734a533aebd36cc4647b48ff342434cdf",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "cb265645385819f3dbe71aac266e319e7f77aed252cacf2930b68102828bf615",
    "sequence_number": 4,
    "success": true,
    "timestamp_us": 1683030933803632,
    "version": 3347495,
    "vm_status": "Executed successfully"
  }
}


Note that the path of the compiled script is under build/run_script/, not build/my_script/. This is because it uses the name of the project contained in Move.toml, which is run_script from when we ran aptos move init --name run_script.

See the code used for this document. The full example explains how to use a Move script that relies on a user-created Move module as well.

See also how to do this with the Rust SDK instead of the Aptos CLI in Stack Overflow.

Advanced
You may execute a script in a more streamlined fashion; instead of running aptos move compile and then aptos move run-script --compiled-script-path separately, you can just do this:

$ aptos move run-script --script-path sources/my_script.move --args address:b078d693856a65401d492f99ca0d6a29a0c5c0e371bc2521570a86e40d95f823 --args u64:5


This will conduct both steps with a single CLI command yet has issues. For this reason, we recommend using the previous two-step approach for now.

Use the Aptos CLI
The aptos tool is a command line interface (CLI) for developing on the Aptos blockchain, debugging, and for node operations. This document describes how to use the aptos CLI tool. To download or build the CLI, follow Install Aptos CLI.

Compiling Move
The aptos CLI can be used to compile a Move package locally. The below example uses the HelloBlockchain in move-examples.

The named addresses can be either an account address, or a profile name.

$ aptos move compile --package-dir aptos-move/move-examples/hello_blockchain/ --named-addresses hello_blockchain=superuser


The above command will generate the below terminal output:

{
  "Result": [
    "742854F7DCA56EA6309B51E8CEBB830B12623F9C9D76C72C3242E4CAD353DEDC::Message"
  ]
}

Compiling and unit testing Move
The aptos CLI can also be used to compile and run unit tests locally. In this example, we'll use the HelloBlockchain in move-examples.

$ aptos move test --package-dir aptos-move/move-examples/hello_blockchain/ --named-addresses hello_blockchain=superuser


The above command will generate the following terminal output:

INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING Examples
Running Move unit tests
[ PASS    ] 0x742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc::MessageTests::sender_can_set_message
[ PASS    ] 0x742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc::Message::sender_can_set_message
Test result: OK. Total tests: 2; passed: 2; failed: 0
{
  "Result": "Success"
}


Generating test coverage details for Move
The aptos CLI can be used to analyze and improve the testing of your Move modules. To use this feature:

In your aptos-core source checkout, navigate to the aptos-move/framework/move-stdlib directory.

Execute the command:

$ aptos move test --coverage

Receive results in standard output containing the result for each test case followed by a basic coverage summary resembling:

BUILDING MoveStdlib
Running Move unit tests
[ PASS    ] 0x1::vector_tests::append_empties_is_empty
[ PASS    ] 0x1::option_tests::borrow_mut_none
[ PASS    ] 0x1::fixed_point32_tests::ceil_can_round_up_correctly
[ PASS    ] 0x1::features::test_change_feature_txn
[ PASS    ] 0x1::bcs_tests::bcs_bool
[ PASS    ] 0x1::bit_vector_tests::empty_bitvector
[ PASS    ] 0x1::option_tests::borrow_mut_some
Test result: OK. Total tests: 149; passed: 149; failed: 0
+-------------------------+
| Move Coverage Summary   |
+-------------------------+
Module 0000000000000000000000000000000000000000000000000000000000000001::bcs
>>> % Module coverage: NaN
Module 0000000000000000000000000000000000000000000000000000000000000001::fixed_point32
>>> % Module coverage: 100.00
Module 0000000000000000000000000000000000000000000000000000000000000001::hash
>>> % Module coverage: NaN
Module 0000000000000000000000000000000000000000000000000000000000000001::vector
>>> % Module coverage: 92.19
Module 0000000000000000000000000000000000000000000000000000000000000001::error
>>> % Module coverage: 0.00
Module 0000000000000000000000000000000000000000000000000000000000000001::acl
>>> % Module coverage: 0.00
Module 0000000000000000000000000000000000000000000000000000000000000001::bit_vector
>>> % Module coverage: 97.32
Module 0000000000000000000000000000000000000000000000000000000000000001::signer
>>> % Module coverage: 100.00
Module 0000000000000000000000000000000000000000000000000000000000000001::features
>>> % Module coverage: 69.41
Module 0000000000000000000000000000000000000000000000000000000000000001::option
>>> % Module coverage: 100.00
Module 0000000000000000000000000000000000000000000000000000000000000001::string
>>> % Module coverage: 81.82
+-------------------------+
| % Move Coverage: 83.50  |
+-------------------------+
Please use `aptos move coverage -h` for more detailed test coverage of this package
{
"Result": "Success"
}

Optionally, narrow down your test runs and results to a specific package name with the --filter option, like so:

$ aptos move test --coverage --filter vector

With results like:

BUILDING MoveStdlib
Running Move unit tests
[ PASS    ] 0x1::bit_vector_tests::empty_bitvector
[ PASS    ] 0x1::vector_tests::append_empties_is_empty
[ PASS    ] 0x1::bit_vector_tests::index_bit_out_of_bounds
[ PASS    ] 0x1::vector_tests::append_respects_order_empty_lhs

Run the aptos move coverage command to obtain more detailed coverage information.

Optionally, isolate the results to a module by passing its name to the --module option, for example:

$ aptos move coverage source --module signer

With results:

module std::signer {
    // Borrows the address of the signer
    // Conceptually, you can think of the `signer` as being a struct wrapper arround an
    // address
    // ```
    // struct signer has drop { addr: address }
    // ```
    // `borrow_address` borrows this inner field
    native public fun borrow_address(s: &signer): &address;

    // Copies the address of the signer
    public fun address_of(s: &signer): address {
        *borrow_address(s)
    }

 /// Return true only if `s` is a transaction signer. This is a spec function only available in spec.
 spec native fun is_txn_signer(s: signer): bool;

 /// Return true only if `a` is a transaction signer address. This is a spec function only available in spec.
 spec native fun is_txn_signer_addr(a: address): bool;
}
{
"Result": "Success"
}


Find failures and iteratively improve your testing and running these commands to eliminate gaps in your testing coverage.

Proving Move
The aptos CLI can be used to run Move Prover, which is a formal verification tool for the Move language. The below example proves the hello_prover package in move-examples.

aptos move prove --package-dir aptos-move/move-examples/hello_prover/

The above command will generate the following terminal output:

SUCCESS proving 1 modules from package `hello_prover` in 1.649s
{
  "Result": "Success"
}

Move Prover may fail with the following terminal output if the dependencies are not installed and set up properly:

FAILURE proving 1 modules from package `hello_prover` in 0.067s
{
  "Error": "Move Prover failed: No boogie executable set.  Please set BOOGIE_EXE"
}

In this case, see Install the dependencies of Move Prover.

Profiling gas usage
This experimental feature lets you profile gas usage in the Aptos virtual machine locally rather than simulating transactions at the fullnode. You may also use it to visualize gas usage in the form of a flame graph.

Run the gas profiler by appending the --profile-gas option to the Aptos CLI move publish, move run or move run-script command, for example:

aptos move publish --profile-gas

And receive output resembling:

Compiling, may take a little while to download git dependencies...
BUILDING empty_fun
package size 427 bytes
Simulating transaction locally with the gas profiler...
This is still experimental so results may be inaccurate.
Execution & IO Gas flamegraph saved to gas-profiling/txn-69e19ee4-0x1-code-publish_package_txn.exec_io.svg
Storage fee flamegraph saved to gas-profiling/txn-69e19ee4-0x1-code-publish_package_txn.storage.svg
{
  "Result": {
    "transaction_hash": "0x69e19ee4cc89cb1f84ee21a46e6b281bd8696115aa332275eca38c4857818dfe",
    "gas_used": 1007,
    "gas_unit_price": 100,
    "sender": "dbcbe741d003a7369d87ec8717afb5df425977106497052f96f4e236372f7dd5",
    "success": true,
    "version": 473269362,
    "vm_status": "status EXECUTED of type Execution"
  }
}


Find the flame graphs in the newly created gas-profiling/ directory. To interact with a graph, open the file in a web browser.

Note these limitations of the experimental gas profiling feature:

It may produce results that are different from the simulation.
The graphs may contain errors, and the numbers may not add up to the total gas cost as shown in the transaction output.
Debugging and printing stack trace
In this example, we will use DebugDemo in debug-move-example.

Now, you can use debug::print and debug::print_stack_trace in your DebugDemo Move file.

You can run the following command:

$ aptos move test --package-dir crates/aptos/debug-move-example

The command will generate the following output:

Running Move unit tests
[debug] 0000000000000000000000000000000000000000000000000000000000000001
Call Stack:
    [0] 0000000000000000000000000000000000000000000000000000000000000001::Message::sender_can_set_message

        Code:
            [4] CallGeneric(0)
            [5] MoveLoc(0)
            [6] LdConst(0)
          > [7] Call(1)
            [8] Ret

        Locals:
            [0] -
            [1] 0000000000000000000000000000000000000000000000000000000000000001


Operand Stack:


Publishing a Move package with a named address
In this example, we'll use the HelloBlockchain in move-examples.

Publish the package with your account address set for HelloBlockchain.

Here, you need to change 8946741e5c907c43c9e042b3739993f32904723f8e2d1491564d38959b59ac71 to your account address.

$ aptos move publish --package-dir aptos-move/move-examples/hello_blockchain/ --named-addresses hello_blockchain=8946741e5c907c43c9e042b3739993f32904723f8e2d1491564d38959b59ac71


TIP
As an open source project, the source code as well as compiled code published to the Aptos blockchain is inherently open by default. This means code you upload may be downloaded from on-chain data. Even without source access, it is possible to regenerate Move source from Move bytecode. To disable source access, publish with the --included-artifacts none argument, like so:

aptos move publish --included-artifacts none

You can additionally use named profiles for the addresses. The first placeholder is default

$ aptos move publish --package-dir aptos-move/move-examples/hello_blockchain/ --named-addresses hello_blockchain=default


TIP
When publishing Move modules, if multiple modules are in one package, then all the modules in this package must have the same account. If they have different accounts, then the publishing will fail at the transaction level.

Running a Move function
Now that you've published the function above, you can run it.

Arguments must be given a type with a colon to separate it. In this example, we want the input to be parsed as a string, so we put string:Hello!.

$ aptos move run --function-id 0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb::message::set_message --args string:hello!
{
  "Result": {
    "changes": [
      {
        "address": "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
        "data": {
          "authentication_key": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
          "self_address": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
          "sequence_number": "3"
        },
        "event": "write_resource",
        "resource": "0x1::account::Account"
      },
      {
        "address": "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
        "data": {
          "coin": {
            "value": "9777"
          },
          "deposit_events": {
            "counter": "1",
            "guid": {
              "id": {
                "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
                "creation_num": "1"
              }
            }
          },
          "withdraw_events": {
            "counter": "1",
            "guid": {
              "id": {
                "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
                "creation_num": "2"
              }
            }
          }
        },
        "event": "write_resource",
        "resource": "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>"
      },
      {
        "address": "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
        "data": {
          "counter": "4"
        },
        "event": "write_resource",
        "resource": "0x1::guid::Generator"
      },
      {
        "address": "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
        "data": {
          "message": "hello!",
          "message_change_events": {
            "counter": "0",
            "guid": {
              "id": {
                "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
                "creation_num": "3"
              }
            }
          }
        },
        "event": "write_resource",
        "resource": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb::Message::MessageHolder"
      }
    ],
    "gas_used": 41,
    "success": true,
    "version": 3488,
    "vm_status": "Executed successfully"
  }
}


Additionally, profiles can replace addresses in the function id.

$ aptos move run --function-id default::message::set_message --args string:hello!
{
  "Result": {
    "changes": [
      {
        "address": "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
        "data": {
          "authentication_key": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
          "self_address": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
          "sequence_number": "3"
        },
        "event": "write_resource",
        "resource": "0x1::account::Account"
      },
      {
        "address": "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
        "data": {
          "coin": {
            "value": "9777"
          },
          "deposit_events": {
            "counter": "1",
            "guid": {
              "id": {
                "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
                "creation_num": "1"
              }
            }
          },
          "withdraw_events": {
            "counter": "1",
            "guid": {
              "id": {
                "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
                "creation_num": "2"
              }
            }
          }
        },
        "event": "write_resource",
        "resource": "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>"
      },
      {
        "address": "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
        "data": {
          "counter": "4"
        },
        "event": "write_resource",
        "resource": "0x1::guid::Generator"
      },
      {
        "address": "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
        "data": {
          "message": "hello!",
          "message_change_events": {
            "counter": "0",
            "guid": {
              "id": {
                "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
                "creation_num": "3"
              }
            }
          }
        },
        "event": "write_resource",
        "resource": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb::Message::MessageHolder"
      }
    ],
    "gas_used": 41,
    "success": true,
    "version": 3488,
    "vm_status": "Executed successfully"
  }
}


Arguments in JSON
Package info
This section references the CliArgs example package, which contains the following manifest:

Move.toml
[package]
name = "CliArgs"
version = "0.1.0"
upgrade_policy = "compatible"

[addresses]
test_account = "_"

[dependencies.AptosFramework]
local = "../../framework/aptos-framework"

Here, the package is deployed under the named address test_account.

TIP
Set your working directory to aptos-move/move-examples/cli_args to follow along:

cd <aptos-core-parent-directory>/aptos-core/aptos-move/move-examples/cli_args

Deploying the package
Start by mining a vanity address for Ace, who will deploy the package:

Command
aptos key generate \
    --vanity-prefix 0xace \
    --output-file ace.key

Output
{
  "Result": {
    "Account Address:": "0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "PublicKey Path": "ace.key.pub",
    "PrivateKey Path": "ace.key"
  }
}

TIP
The exact account address should vary for each run, though the vanity prefix should not.

Store Ace's address in a shell variable so you can call it inline later on:

# Your exact address should vary
ace_addr=0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46

Fund Ace's account with the faucet (either devnet or testnet):

Command
aptos account fund-with-faucet --account $ace_addr

Output
{
  "Result": "Added 100000000 Octas to account acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46"
}


Now publish the package under Ace's account:

Command
aptos move publish \
    --named-addresses test_account=$ace_addr \
    --private-key-file ace.key \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0x1d7b074dd95724c5459a1c30fe4cb3875e7b0478cc90c87c8e3f21381625bec1",
    "gas_used": 1294,
    "gas_unit_price": 100,
    "sender": "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1685077849297587,
    "version": 528422121,
    "vm_status": "Executed successfully"
  }
}

Entry functions
The only module in the package, cli_args.move, defines a simple Holder resource with fields of various data types:

Holder in cli_args.move
module test_account::cli_args {
    use std::signer;
    use aptos_std::type_info::{Self, TypeInfo};
    use std::string::String;

    struct Holder has key, drop {
        u8_solo: u8,
        bytes: vector<u8>,
        utf8_string: String,
        bool_vec: vector<bool>,
        address_vec_vec: vector<vector<address>>,
        type_info_1: TypeInfo,
        type_info_2: TypeInfo,
    } 

A public entry function with multi-nested vectors can be used to set the fields:

Setter function in cli_args.move
/// Set values in a `Holder` under `account`.
public entry fun set_vals<T1, T2>(
    account: signer,
    u8_solo: u8,
    bytes: vector<u8>,
    utf8_string: String,
    bool_vec: vector<bool>,
    address_vec_vec: vector<vector<address>>,
) acquires Holder {
    let account_addr = signer::address_of(&account);
    if (exists<Holder>(account_addr)) {
        move_from<Holder>(account_addr);
    };
    move_to(&account, Holder {
        u8_solo,
        bytes,
        utf8_string,
        bool_vec,
        address_vec_vec,
        type_info_1: type_info::type_of<T1>(),
        type_info_2: type_info::type_of<T2>(),
    });
} 

After the package has been published, aptos move run can be used to call set_vals():

TIP
To pass vectors (including nested vectors) as arguments from the command line, use JSON syntax escaped with quotes!

Running function with nested vector arguments from CLI
aptos move run \
    --function-id $ace_addr::cli_args::set_vals \
    --type-args \
        0x1::account::Account \
        0x1::chain_id::ChainId \
    --args \
        u8:123 \
        "hex:0x1234" \
        "string:hello, world\! ♥" \
        "bool:[false, true, false, false]" \
        'address:[["0xace", "0xbee"], ["0xcad"], []]' \
    --private-key-file ace.key \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0x5e141dc6c28e86fa9f5594de93d07a014264ebadfb99be6db922a929eb1da24f",
    "gas_used": 504,
    "gas_unit_price": 100,
    "sender": "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "sequence_number": 1,
    "success": true,
    "timestamp_us": 1685077888820037,
    "version": 528422422,
    "vm_status": "Executed successfully"
  }
}

The function ID, type arguments, and arguments can alternatively be specified in a JSON file:

entry_function_arguments.json
{
    "function_id": "<test_account>::cli_args::set_vals",
    "type_args": [
        "0x1::account::Account",
        "0x1::chain_id::ChainId"
    ],
    "args": [
        {
            "type": "u8",
            "value": 123
        },
        {
            "type": "hex",
            "value": "0x1234"
        },
        {
            "type": "string",
            "value": "hello, world! ♥"
        },
        {
            "type": "bool",
            "value": [
                false,
                true,
                false,
                false
            ]
        },
        {
            "type": "address",
            "value": [
                [
                    "0xace",
                    "0xbee"
                ],
                [
                    "0xcad"
                ],
                []
            ]
        }
    ]
}

Here, the call to aptos move run looks like:

Running function with JSON input file
aptos move run \
    --json-file entry_function_arguments.json \
    --private-key-file ace.key \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0x60a32315bb48bf6d31629332f6b1a3471dd0cb016fdee8d0bb7dcd0be9833e60",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "sequence_number": 2,
    "success": true,
    "timestamp_us": 1685077961499641,
    "version": 528422965,
    "vm_status": "Executed successfully"
  }
}

TIP
If you are trying to run the example yourself don't forget to substitute Ace's actual address for <test_account> in entry_function_arguments.json!

View functions
Once the values in a Holder have been set, the reveal() view function can be used to check the first three fields, and to compare type arguments against the last two fields:

View function
    struct RevealResult has drop {
        u8_solo: u8,
        bytes: vector<u8>,
        utf8_string: String,
        bool_vec: vector<bool>,
        address_vec_vec: vector<vector<address>>,
        type_info_1_match: bool,
        type_info_2_match: bool
    }

    #[view]
    /// Pack into a `RevealResult` the first three fields in host's
    /// `Holder`, as well as two `bool` flags denoting if `T1` & `T2`
    /// respectively match `Holder.type_info_1` & `Holder.type_info_2`,
    /// then return the `RevealResult`.
    public fun reveal<T1, T2>(host: address): RevealResult acquires Holder {
        let holder_ref = borrow_global<Holder>(host);
        RevealResult {
            u8_solo: holder_ref.u8_solo,
            bytes: holder_ref.bytes,
            utf8_string: holder_ref.utf8_string,
            bool_vec: holder_ref.bool_vec,
            address_vec_vec: holder_ref.address_vec_vec,
            type_info_1_match:
                type_info::type_of<T1>() == holder_ref.type_info_1,
            type_info_2_match:
                type_info::type_of<T2>() == holder_ref.type_info_2
        }
    }

} 

This view function can be called with arguments specified either from the CLI or from a JSON file:

Arguments via CLI
aptos move view \
    --function-id $ace_addr::cli_args::reveal \
    --type-args \
        0x1::account::Account \
        0x1::account::Account \
    --args address:$ace_addr

Arguments via JSON file
aptos move view --json-file view_function_arguments.json

TIP
If you are trying to run the example yourself don't forget to substitute Ace's actual address for <test_account> in view_function_arguments.json (twice)!

view_function_arguments.json
{
    "function_id": "<test_account>::cli_args::reveal",
    "type_args": [
        "0x1::account::Account",
        "0x1::account::Account"
    ],
    "args": [
        {
            "type": "address",
            "value": "<test_account>"
        }
    ]
}

Output
{
  "Result": [
    {
      "address_vec_vec": [
        [
          "0xace",
          "0xbee"
        ],
        [
          "0xcad"
        ],
        []
      ],
      "bool_vec": [
        false,
        true,
        false,
        false
      ],
      "bytes": "0x1234",
      "type_info_1_match": true,
      "type_info_2_match": false,
      "u8_solo": 123,
      "utf8_string": "hello, world! ♥"
    }
  ]
}

Script functions
The package also contains a script, set_vals.move, which is a wrapper for the setter function:

script
script {
    use test_account::cli_args;
    use std::vector;
    use std::string::String;

    /// Get a `bool` vector where each element indicates `true` if the
    /// corresponding element in `u8_vec` is greater than `u8_solo`.
    /// Then pack `address_solo` in a `vector<vector<<address>>` and
    /// pass resulting argument set to public entry function.
    fun set_vals<T1, T2>(
        account: signer,
        u8_solo: u8,
        bytes: vector<u8>,
        utf8_string: String,
        u8_vec: vector<u8>,
        address_solo: address,
    ) {
        let bool_vec = vector::map_ref(&u8_vec, |e_ref| *e_ref > u8_solo);
        let addr_vec_vec = vector[vector[address_solo]];
        cli_args::set_vals<T1, T2>(account, u8_solo, bytes, utf8_string, bool_vec, addr_vec_vec);
    }
} 

First compile the package (this will compile the script):

Compilation
aptos move compile --named-addresses test_account=$ace_addr

Output
{
  "Result": [
    "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46::cli_args"
  ]
}

Next, run aptos move run-script:

Arguments via CLI
aptos move run-script \
    --compiled-script-path build/CliArgs/bytecode_scripts/set_vals.mv \
    --type-args \
        0x1::account::Account \
        0x1::chain_id::ChainId \
    --args \
        u8:123 \
        "hex:0x1234" \
        "string:hello, world\! ♥" \
        "u8:[122, 123, 124, 125]" \
        address:"0xace" \
    --private-key-file ace.key \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0x1d644eba8187843cc43919469112339bc2c435a49a733ac813b7bc6c79770152",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "sequence_number": 3,
    "success": true,
    "timestamp_us": 1685078415935612,
    "version": 528426413,
    "vm_status": "Executed successfully"
  }
}

Arguments via JSON file
aptos move run-script \
    --compiled-script-path build/CliArgs/bytecode_scripts/set_vals.mv \
    --json-file script_function_arguments.json \
    --private-key-file ace.key \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0x840e2d6a5ab80d5a570effb3665f775f1755e0fd8d76e52bfa7241aaade883d7",
    "gas_used": 3,
    "gas_unit_price": 100,
    "sender": "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "sequence_number": 4,
    "success": true,
    "timestamp_us": 1685078516832128,
    "version": 528427132,
    "vm_status": "Executed successfully"
  }
}

script_function_arguments.json
{
    "type_args": [
        "0x1::account::Account",
        "0x1::chain_id::ChainId"
    ],
    "args": [
        {
            "type": "u8",
            "value": 123
        },
        {
            "type": "hex",
            "value": "0x1234"
        },
        {
            "type": "string",
            "value": "hello, world! ♥"
        },
        {
            "type": "u8",
            "value": [
                122,
                123,
                124,
                125
            ]
        },
        {
            "type": "address",
            "value": "0xace"
        }
    ]
}

Both such script function invocations result in the following reveal() view function output:

View function call
aptos move view \
    --function-id $ace_addr::cli_args::reveal \
    --type-args \
        0x1::account::Account \
        0x1::chain_id::ChainId \
    --args address:$ace_addr

View function output
{
  "Result": [
    {
      "address_vec_vec": [
        [
          "0xace"
        ]
      ],
      "bool_vec": [
        false,
        false,
        true,
        true
      ],
      "bytes": "0x1234",
      "type_info_1_match": true,
      "type_info_2_match": true,
      "u8_solo": 123,
      "utf8_string": "hello, world! ♥"
    }
  ]
}

NOTE
As of the time of this writing, the aptos CLI only supports script function arguments for vectors of type u8, and only up to a vector depth of 1. Hence vector<address> and vector<vector<u8>> are invalid script function argument types.

Multisig governance
Background
This section builds upon the Arguments in JSON section, and likewise references the CliArgs example package.

TIP
If you would like to follow along, start by completing the Arguments in JSON tutorial steps!

For this example, Ace and Bee will conduct governance operations from a 2-of-2 "multisig v2" account (an on-chain multisig account per multisig_account.move)

Account creation
Since Ace's account was created during the Arguments in JSON tutorial, start by mining a vanity address account for Bee too:

Command
aptos key generate \
    --vanity-prefix 0xbee \
    --output-file bee.key

Output
{
  "Result": {
    "PublicKey Path": "bee.key.pub",
    "PrivateKey Path": "bee.key",
    "Account Address:": "0xbeec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc"
  }
}

TIP
The exact account address should vary for each run, though the vanity prefix should not.

Store Bee's address in a shell variable so you can call it inline later on:

# Your exact address should vary
bee_addr=0xbeec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc

Fund Bee's account using the faucet:

Command
aptos account fund-with-faucet --account $bee_addr

Output
{
  "Result": "Added 100000000 Octas to account beec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc"
}


Ace can now create a multisig account:

Command
aptos multisig create \
    --additional-owners $bee_addr \
    --num-signatures-required 2 \
    --private-key-file ace.key \
    --assume-yes

Output
{
  "Result": {
    "multisig_address": "57478da34604655c68b1dcb89e4f4a9124b6c0ecc1c59a0931d58cc4e60ac5c5",
    "transaction_hash": "0x849cc756de2d3b57210f5d32ae4b5e7d1f80e5d376233885944b6f3cc2124a05",
    "gas_used": 1524,
    "gas_unit_price": 100,
    "sender": "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "sequence_number": 5,
    "success": true,
    "timestamp_us": 1685078644186194,
    "version": 528428043,
    "vm_status": "Executed successfully"
  }
}

Store the multisig address in a shell variable:

# Your address should vary
multisig_addr=0x57478da34604655c68b1dcb89e4f4a9124b6c0ecc1c59a0931d58cc4e60ac5c5

Inspect the multisig
Use the assorted multisig_account.move view functions to inspect the multisig:

Number of signatures required
aptos move view \
    --function-id 0x1::multisig_account::num_signatures_required \
    --args \
        address:"$multisig_addr"

Output
{
  "Result": [
    "2"
  ]
}

Owners
aptos move view \
    --function-id 0x1::multisig_account::owners \
    --args \
        address:"$multisig_addr"

Output
{
  "Result": [
    [
      "0xbeec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc",
      "0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46"
    ]
  ]
}

Last resolved sequence number
aptos move view \
    --function-id 0x1::multisig_account::last_resolved_sequence_number \
    --args \
        address:"$multisig_addr"

Output
{
  "Result": [
    "0"
  ]
}

Next sequence number
aptos move view \
    --function-id 0x1::multisig_account::next_sequence_number \
    --args \
        address:"$multisig_addr"

Output
{
  "Result": [
    "1"
  ]
}

Enqueue a publication transaction
The first multisig transaction enqueued will be a transaction for publication of the CliArgs example package. First, generate a publication payload entry function JSON file:

Command
aptos move build-publish-payload \
    --named-addresses test_account=$multisig_addr \
    --json-output-file publication.json \
    --assume-yes

Output
{
  "Result": "Publication payload entry function JSON file saved to publication.json"
}

Now have Ace propose publication of the package from the multisig account, storing only the payload hash on-chain:

Command
aptos multisig create-transaction \
    --multisig-address $multisig_addr \
    --json-file publication.json \
    --store-hash-only \
    --private-key-file ace.key \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0x70c75903f8e1b1c0069f1e84ef9583ad8000f24124b33a746c88d2b031f7fe2c",
    "gas_used": 510,
    "gas_unit_price": 100,
    "sender": "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "sequence_number": 6,
    "success": true,
    "timestamp_us": 1685078836492390,
    "version": 528429447,
    "vm_status": "Executed successfully"
  }
}

Note that the last resolved sequence number is still 0 because no transactions have been resolved:

Last resolved sequence number
aptos move view \
    --function-id 0x1::multisig_account::last_resolved_sequence_number \
    --args \
        address:"$multisig_addr"

Output
{
  "Result": [
    "0"
  ]
}

However the next sequence number has been incremented because a transaction has been enqueued:

Next sequence number
aptos move view \
    --function-id 0x1::multisig_account::next_sequence_number \
    --args \
        address:"$multisig_addr"

Output
{
  "Result": [
    "2"
  ]
}

The multisig transaction enqueued on-chain can now be inspected:

Get transaction
aptos move view \
    --function-id 0x1::multisig_account::get_transaction \
    --args \
        address:"$multisig_addr" \
        String:1

Output
{
  "Result": [
    {
      "creation_time_secs": "1685078836",
      "creator": "0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
      "payload": {
        "vec": []
      },
      "payload_hash": {
        "vec": [
          "0x62b91159c1428c1ef488c7290771de458464bd665691d9653d195bc28e0d2080"
        ]
      },
      "votes": {
        "data": [
          {
            "key": "0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
            "value": true
          }
        ]
      }
    }
  ]
}

Note from the above result that no payload is stored on-chain, and that Ace implicitly approved the transaction (voted true) upon the submission of the proposal.

Enqueue a governance parameter transaction
Now have Bee enqueue a governance parameter setter transaction, storing the entire transaction payload on-chain:

Command
aptos multisig create-transaction \
    --multisig-address $multisig_addr \
    --function-id $multisig_addr::cli_args::set_vals \
    --type-args \
        0x1::account::Account \
        0x1::chain_id::ChainId \
    --args \
        u8:123 \
        "bool:[false, true, false, false]" \
        'address:[["0xace", "0xbee"], ["0xcad"], []]' \
    --private-key-file bee.key \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0xd0a348072d5bfc5a2e5d444f92f0ecc10b978dad720b174303bc6d91342f27ec",
    "gas_used": 511,
    "gas_unit_price": 100,
    "sender": "beec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1685078954841650,
    "version": 528430315,
    "vm_status": "Executed successfully"
  }
}

Note the next sequence number has been incremented again:

Next sequence number
aptos move view \
    --function-id 0x1::multisig_account::next_sequence_number \
    --args \
        address:"$multisig_addr"

Output
{
  "Result": [
    "3"
  ]
}

Now both the publication and parameter transactions are pending:

Get pending transactions
aptos move view \
    --function-id 0x1::multisig_account::get_pending_transactions \
    --args \
        address:"$multisig_addr"

Output
{
  "Result": [
    [
      {
        "creation_time_secs": "1685078836",
        "creator": "0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
        "payload": {
          "vec": []
        },
        "payload_hash": {
          "vec": [
            "0x62b91159c1428c1ef488c7290771de458464bd665691d9653d195bc28e0d2080"
          ]
        },
        "votes": {
          "data": [
            {
              "key": "0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
              "value": true
            }
          ]
        }
      },
      {
        "creation_time_secs": "1685078954",
        "creator": "0xbeec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc",
        "payload": {
          "vec": [
            "0x0057478da34604655c68b1dcb89e4f4a9124b6c0ecc1c59a0931d58cc4e60ac5c508636c695f61726773087365745f76616c7302070000000000000000000000000000000000000000000000000000000000000001076163636f756e74074163636f756e740007000000000000000000000000000000000000000000000000000000000000000108636861696e5f696407436861696e49640003017b0504000100006403020000000000000000000000000000000000000000000000000000000000000ace0000000000000000000000000000000000000000000000000000000000000bee010000000000000000000000000000000000000000000000000000000000000cad00"
          ]
        },
        "payload_hash": {
          "vec": []
        },
        "votes": {
          "data": [
            {
              "key": "0xbeec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc",
              "value": true
            }
          ]
        }
      }
    ]
  ]
}


Execute the publication transaction
Since only Ace has voted on the publication transaction (which he implicitly approved upon proposing) the transaction can't be executed yet:

Can be executed
aptos move view \
    --function-id 0x1::multisig_account::can_be_executed \
    --args \
        address:"$multisig_addr" \
        String:1

Output
{
  "Result": [
    false
  ]
}

Before Bee votes, however, she verifies that the payload hash stored on-chain matches the publication entry function JSON file:

Verifying transaction proposal
aptos multisig verify-proposal \
    --multisig-address $multisig_addr \
    --json-file publication.json \
    --sequence-number 1

Output
{
  "Result": {
    "Status": "Transaction match",
    "Multisig transaction": {
      "creation_time_secs": "1685078836",
      "creator": "0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
      "payload": {
        "vec": []
      },
      "payload_hash": {
        "vec": [
          "0x62b91159c1428c1ef488c7290771de458464bd665691d9653d195bc28e0d2080"
        ]
      },
      "votes": {
        "data": [
          {
            "key": "0xacef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
            "value": true
          }
        ]
      }
    }
  }
}

Since Bee has verified that the on-chain payload hash checks out against her locally-compiled package publication JSON file, she votes yes:

Approving transaction
aptos multisig approve \
    --multisig-address $multisig_addr \
    --sequence-number 1 \
    --private-key-file bee.key \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0xa5fb49f1077de6aa6d976e6bcc05e4c50c6cd061f1c87e8f1ea74e7a04a06bd1",
    "gas_used": 6,
    "gas_unit_price": 100,
    "sender": "beec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc",
    "sequence_number": 1,
    "success": true,
    "timestamp_us": 1685079892130861,
    "version": 528437204,
    "vm_status": "Executed successfully"
  }
}

Now the transaction can be executed:

Can be executed
aptos move view \
    --function-id 0x1::multisig_account::can_be_executed \
    --args \
        address:"$multisig_addr" \
        String:1

Output
{
  "Result": [
    true
  ]
}

Now either Ace or Bee can invoke the publication transaction from the multisig account, passing the full transaction payload since only the hash was stored on-chain:

Publication
aptos multisig execute-with-payload \
    --multisig-address $multisig_addr \
    --json-file publication.json \
    --private-key-file bee.key \
    --max-gas 10000 \
    --assume-yes

TIP
Pending the resolution of #8304, the transaction simulator (which is used to estimate gas costs) is broken for multisig transactions, so you will have to manually specify a max gas amount.

Output
Also pending the resolution of #8304, the CLI output for a successful multisig publication transaction execution results in an API error if only the payload hash has been stored on-chain, but the transaction can be manually verified using an explorer.

Execute the governance parameter transaction
Since only Bee has voted on the governance parameter transaction (which she implicitly approved upon proposing), the transaction can't be executed yet:

Can be executed
aptos move view \
    --function-id 0x1::multisig_account::can_be_executed \
    --args \
        address:"$multisig_addr" \
        String:2

Output
{
  "Result": [
    false
  ]
}

Before Ace votes, however, he verifies that the payload stored on-chain matches the function arguments he expects:

Verifying transaction proposal
aptos multisig verify-proposal \
    --multisig-address $multisig_addr \
    --function-id $multisig_addr::cli_args::set_vals \
    --type-args \
        0x1::account::Account \
        0x1::chain_id::ChainId \
    --args \
        u8:123 \
        "bool:[false, true, false, false]" \
        'address:[["0xace", "0xbee"], ["0xcad"], []]' \
    --sequence-number 2

Output
{
  "Result": {
    "Status": "Transaction match",
    "Multisig transaction": {
      "creation_time_secs": "1685078954",
      "creator": "0xbeec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc",
      "payload": {
        "vec": [
          "0x0057478da34604655c68b1dcb89e4f4a9124b6c0ecc1c59a0931d58cc4e60ac5c508636c695f61726773087365745f76616c7302070000000000000000000000000000000000000000000000000000000000000001076163636f756e74074163636f756e740007000000000000000000000000000000000000000000000000000000000000000108636861696e5f696407436861696e49640003017b0504000100006403020000000000000000000000000000000000000000000000000000000000000ace0000000000000000000000000000000000000000000000000000000000000bee010000000000000000000000000000000000000000000000000000000000000cad00"
        ]
      },
      "payload_hash": {
        "vec": []
      },
      "votes": {
        "data": [
          {
            "key": "0xbeec980219d246581cef5166dc6ba5fb1e090c7a7786a5176d111a9029b16ddc",
            "value": true
          }
        ]
      }
    }
  }
}


Note that the verification fails if he modifies even a single argument:

Failed transaction verification with modified u8
aptos multisig verify-proposal \
    --multisig-address $multisig_addr \
    --function-id $multisig_addr::cli_args::set_vals \
    --type-args \
        0x1::account::Account \
        0x1::chain_id::ChainId \
    --args \
        u8:200 \
        "bool:[false, true, false, false]" \
        'address:[["0xace", "0xbee"], ["0xcad"], []]' \
    --sequence-number 2

Output
{
  "Error": "Unexpected error: Transaction mismatch: The transaction you provided has a payload hash of 0xe494b0072d6f940317344967cf0e818c80082375833708c773b0275f3ad07e51, but the on-chain transaction proposal you specified has a payload hash of 0x070ed7c3f812f25f585461305d507b96a4e756f784e01c8c59901871267a1580. For more info, see https://aptos.dev/move/move-on-aptos/cli#multisig-governance"
}


Ace approves the transaction:

Approving transaction
aptos multisig approve \
    --multisig-address $multisig_addr \
    --sequence-number 2 \
    --private-key-file ace.key \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0x233427d95832234fa13dddad5e0b225d40168b4c2c6b84f5255eecc3e68401bf",
    "gas_used": 6,
    "gas_unit_price": 100,
    "sender": "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "sequence_number": 7,
    "success": true,
    "timestamp_us": 1685080266378400,
    "version": 528439883,
    "vm_status": "Executed successfully"
  }
}

Since the payload was stored on-chain, it is not required to execute the pending transaction:

Execution
aptos multisig execute \
    --multisig-address $multisig_addr \
    --private-key-file ace.key \
    --max-gas 10000 \
    --assume-yes

Output
{
  "Result": {
    "transaction_hash": "0xbc99f929708a1058b223aa880d04607a78ebe503367ec4dab23af4a3bdb541b2",
    "gas_used": 505,
    "gas_unit_price": 100,
    "sender": "acef1b9b7d4ab208b99fed60746d18dcd74865edb7eb3c3f1428233988e4ba46",
    "sequence_number": 8,
    "success": true,
    "timestamp_us": 1685080344045461,
    "version": 528440423,
    "vm_status": "Executed successfully"


Cryptography in Move
Cryptography plays an integral role in ensuring the security, integrity, confidentiality, and immutability of data in blockchain systems. The Aptos adapter for Move provides developers with an array of cryptographic primitives to cater to this need. This document delves into the cryptographic functionalities offered by Move on Aptos and elucidates the principles that drive their design.

Cryptographic primitives
Move, through the Aptos adapter, encompasses several fundamental cryptographic tools:

Cryptographic Hash Functions – Algorithms that produce a fixed-size output (hash) from variable-sized input data. Supported functions include SHA2-256, SHA3-256, Keccak256, and Blake2b-256.
Digital Signature Verification – Algorithms for signing a message so as to ensure its integrity, authenticate its sender, ensure non-repudiation, or any combination thereof. Supported signature schemes include Ed25519, ECDSA, and BLS.
Elliptic Curve Arithmetic – Elliptic curves are one of the building blocks of advanced cryptographic primitives, such as digital signatures, public-key encryption or verifiable secret sharing. Supported curves include Ristretto255 and BLS12-381.
Zero-Knowledge Proofs (ZKP) – These cryptographic techniques enable a party to prove that a relation 
�
(
�
;
�
)
R(x;w) is satisfied on a public statement 
�
x without leaking the secret witness 
�
w that makes it hold. Currently, we support Groth16 ZKP verification and Bulletproofs ZK range proof verification.
Three fundamental principles guide the design and integration of the Aptos cryptographic extensions into Move:

Economic Gas Usage – Striving to minimize gas costs for Move developers by implementing key primitives as Move native functions. For example, see the module for BLS signatures over BLS12-381 elliptic curves.
Type-Safe APIs – Ensuring that APIs are resistant to common mistakes, type-safety enhances code reliability and promotes an efficient development process. For an example, see the Ed25519 signature module.
Empowerment of Developers – In instances where native functions are unavailable, we empower developers to build their own cryptographic primitives on top of abstract cryptographic building blocks such as finite fields and Abelian groups. Refer to the aptos_std::crypto_algebra module for more insights.
Continue reading to delve a bit deeper and uncover some of the intricacies behind these extensions, as well as the range of applications they empower. For the most comprehensive understanding of this subject, refer to the cryptography Move modules code.

Cryptographic hash functions
Developers can now use more cryptographic hash functions in Move via the aptos_std::aptos_hash module:

Hash function	Hash size (bits)	Cost for hashing 1KiB (in internal gas units)	Collision-resistance security (bits)
Keccak256	256	1,001,600	128
SHA2-256	256	1,084,000	128
SHA2-512	512	1,293,600	256
SHA3-256	256	1,001,600	128
SHA3-512	512	1,114,000	256
RIPEMD160	160	1,084,000	80 (weak)
Blake2b-256	256	342,200	128
All hash functions have the same security properties (e.g., one-wayness, collision resistance, etc.), but their security levels are different.

CAUTION
RIPEMD160 should be avoided as a collision-resistant function due to its 80-bit security level. It is mainly supported for backward-compatibility reasons: e.g., Bitcoin address derivation relies on RIPEMD160.

Some of these functions can be used for interoperability with other chains (e.g., verifying Ethereum Merkle proofs via aptos_std::aptos_hash::keccak256). Others, have lower gas costs, such as aptos_std::aptos_hash::blake2b_256. In general, a wider variety of hash functions give developers additional freedom in terms of both security and interoperability with other off-chain cryptographic systems.

Digital signature verification
Developers can now use a type-safe API for verifying many kinds of digital signatures in Move:

Signature scheme	Curve	Sig. size (bytes)	PK size (bytes)	Malleability	Assumptions	Pros	Cons
ECDSA	secp256k1	64	64	Yes	GGM	Wide adoption	Security proof
Ed25519	Edwards 25519	64	32	No	DLA, ROM	Fast	Subtleties
MultiEd25519	Edwards 25519	
4
+
�
⋅
64
4+t⋅64	
�
⋅
32
n⋅32	No	DLA, ROM	Easy-to-adopt	Large sig. size
MinPK BLS	BLS12-381	96	48	No	CDH, ROM	Versatile	Slower verification
MinSig BLS	BLS12-381	48	96	No	CDH, ROM	Versatile	Slower verification
NOTE
CDH stands for the "Computational Diffie-Hellman Assumption"
DLA stands for the "Discrete Log Assumption"
GGM stands for the "Generic Group Model"
ROM stands for the "Random Oracle Model"
The digital signature modules above can be used to build smart contract-based wallets, secure claiming mechanisms for airdrops, or any digital-signature-based access-control mechanism for dapps.

The right choice of a signature scheme in your dapp could depend on many factors:

Backwards-compatibility
If your dapp's user base predominantly uses a particular signing mechanism, it would be prudent to support that mechanism for ease of transition and adoption.
Example: If users mainly sign using Ed25519, it becomes a logical choice.
Ease-of-implementation
While theoretically sound, complex protocols may be challenging to implement in practice.
Example: Even though 
�
t-out-of-
�
n threshold protocols for Ed25519 exist, their intricacy on the signer's side might push developers toward MultiEd25519 due to its more straightforward signing implementation.
Efficiency
Depending on the dapp's requirements, you might prioritize one aspect of efficiency over another.
Signature size vs. public key size: Some applications might prioritize a smaller signature footprint, while others might emphasize a compact PK.
Signing time vs. verification time: For certain dapps, the signing speed might be more crucial, while for others, rapid signature verification could be the priority.
Security analysis
It is essential to consider the underlying assumptions and potential vulnerabilities of a signature scheme.
Example: ECDSA's security is proven under strong assumptions such as the Generic Group Model (GGM).
Malleability concerns: Some signature schemes are susceptible to malleability, where a valid signature, 
�
σ, can be mauled into a different yet still valid signature, 
�
′
σ 
′
 , for the same message 
�
m.
Versatility
The adaptability and flexibility of signature schemes are important to consider so you may properly accommodate the cryptographic needs of your dapp.
Example: 
�
t-out-of-
�
n threshold BLS signatures are very simple to implement.
CAUTION
Despite its careful, principled designed25519, Ed25519 has known implementation subtleties. For example, different implementations could easily disagree on the validity of signatures, especially when batch verification is employeddevalence
,
,
 eddsa.

TIP
Our aptos_std::bls12381 module for MinPK BLS supports verification of individual signatures, multi-signatures, aggregate signatures and threshold signatures.

Elliptic curve arithmetic
While the hash function and digital signature modules should provide enough functionality for most applications, some applications will require more powerful cryptography. Normally, developers of such applications would have to wait until their desired crytographic functionality is implemented efficiently as a Move native function in the Aptos Move framework. Instead, we expose basic building blocks that developers can use to implement their own cryptographic primitives directly in the Move language and do so efficiently.

Specifically, we currently expose low-level arithmetic operations on two popular elliptic curve groups and their associated finite fields:

Ristretto255, via aptos_std::ristretto255
BLS12-381, via aptos_std::crypto_algebra and aptos_std::bls12381_algebra
These modules support low-level operations such as:

scalar multiplication of elliptic curve points
multi-scalar multiplications (MSMs)
pairings
scalar addition, multiplication, inversion
hashing to a scalar or to a point
and many more
Examples of powerful applications that can be built on top include:

Validity rollups – See the groth16 zkSNARK verifier example.
Randomness-based games – See the drand verifier example.
Privacy-preserving applications – See the veiled_coin example.
Ristretto255 arithmetic
The aptos_std::ristretto255 module provides support for elliptic curve arithmetic on the popular Ristretto255 curve. One of the main advantages of Ristretto255 is that it is a prime order group (unlike the Edwards 25519 curve), which obviates small-subgroup attacks on higher-level cryptosystems built on top of it. Furthermore, Ristretto255 serialization is canonical and deserialization only accepts canonical encodings, which obviates malleability issues in higher-level protocols.

This module has proven useful for implementing several cryptographic primitives:

Zero-knowledge 
Σ
Σ-protocols – See the veiled_coin example.
ElGamal encryption – See aptos_std::ristretto255_elgamal
Pedersen commitments – See aptos_std::ristretto255_pedersen
Bulletproofs ZK range proofsbulletproofs – See aptos_std::ristretto255_bulletproofs
Need ideas for a cryptosystem to build on top of ristretto255? A popular primitive that you could easily build would be the schnorrkel signature scheme, which is a hardended version of Schnorr signatures over Ristretto255 groups.

Generic elliptic curve arithmetic
What is better than one curve? More curves!

The aptos_std::crypto_algebra provides elliptic curve arithmetic operations for any supported elliptic curve, including pairing-friendly curves. As a consequence, Move developers can implement a cryptosystem generically over any curve that is or will be supported in the future. Compared to fixing a particular curve in the code (e.g., by implementing against the Ristretto255 module), this approach provides more flexibility and lowers development time when migrating to a different curve.

Although currently the crypto_algebra module only supports arithmetic over BLS12-381 curves (via the marker types declared in aptos_std::bls12381_algebra), more curves will be supported into the future (e.g., BN254, Ristretto255, BLS12-377, BW6-761, secp256k1, secp256r1).

As an example, a Move developer can implement the popular Boneh-Lynn-Shacham (BLS) signature scheme generically over any curve by using type arguments for the curve type in their implementation:

Generic BLS signature verification over any curve
use std::option;
use aptos_std::crypto_algebra::{eq, pairing, one, deserialize, hash_to};

/// Example of a BLS signature verification function that works over any pairing-friendly
/// group triple `Gr1`, `Gr2`, `GrT` where signatures are in `Gr1` and PKs in `Gr2`.
/// Points are serialized using the format in `FormatG1` and `FormatG2` and the hashing 
/// method is `HashMethod`.
/// 
/// WARNING: This example is type-unsafe and probably not a great fit for production code.
public fun bls_verify_sig<Gr1, Gr2, GrT, FormatG1, FormatG2, HashMethod>(
    dst:        vector<u8>,
    signature:  vector<u8>,
    message:    vector<u8>,
    public_key: vector<u8>): bool
{
    let sig  = option::extract(&mut deserialize<Gr1, FormatG1>(&signature));
    let pk   = option::extract(&mut deserialize<Gr2, FormatG2>(&public_key));
    let hash = hash_to<Gr1, HashMethod>(&dst, &message);
    
    // Checks if $e(H(m), pk) = e(sig, g_2)$, where $g_2$ generates $\mathbb{G}_2$
    eq(
        &pairing<Gr1, Gr2, GrT>(&hash, &pk), 
        &pairing<Gr1, Gr2, GrT>(&sig, &one<Gr2>())
    )
}

Using the bls_verify_sig generic function from above, developers can verify BLS signatures over any of the supported (pairing-friendly) curves. For example, one can verify MinSig BLS signatures over BLS12-381 curves by calling the function above with the right BLS12-381 marker types as its type arguments:

MinSig BLS signature verification over BLS12-381
use aptos_std::bls12381_algebra::{
    G1, G2, Gt, FormatG1Compr, FormatG2Compr, HashG1XmdSha256SswuRo
};

// Aborts with code 1 if the MinSig BLS signature over the BLS12-381 curve fails to verify. 
assert(
    bls_verify_sig<G1, G2, Gt, FormatG1Compr, FormatG2Compr, HashG1XmdSha256SswuRo>(
        dst, signature, message, public_key
    ),
    1
);

For more use cases of the crypto_algebra module, check out some Move examples:

Verifying Groth16 zkSNARK proofs over any curve
Verifying randomness from the drand beacon
Building powerful cryptographic applications
Veiled coins
The veiled_coin example demonstrates how to use the Ristretto255 modules from above to add a reasonable layer of confidentiality to coin balances and transactions.

Specifically, users can veil their balance, keeping it hidden from everyone, including validators. Furthermore, a user can send a veiled transaction that hides the transaction amount from everybody, including validators. An important caveat is that veiled transactions do not hide the identities of the sender or the recipient.

DANGER
This module is educational. It is not production-ready. Using it could lead to loss of funds.

Groth16 zkSNARK verifier
The groth16 example demonstrates how to verify Groth16 zkSNARK proofsgroth16, which are the shortest, fastest-to-verify, general-purpose zero-knowledge proofs. Importantly, as explained above, this implementation is generic over any curve, making it very easy for Move developers to use it with their favorite (supported) curves.

CAUTION
This code has not been audited by a third-party organization. If using it in a production system, proceed at your own risk.

Verifying randomness from the drand beacon
The drand example shows how to verify public randomness from the drand randomness beacon. This randomness can be used in games or any other chance-based smart contract. We give a simple example of a lottery implemented on top of drand randomness in lottery.move.

CAUTION
This code has not been audited by a third-party organization. If using it in a production system, proceed at your own risk.

Another application that can be built on top of drand is time-lock encryptiontlock, which allows users to encrypt information such that it can only be decrypted in a future block. We do not currently have an implementation but the reader is encouraged to write one!

ed25519: Ed25519: high-speed high-security signatures, by Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, Bo-Yin Yang, https://ed25519.cr.yp.to/↩
devalence: It’s 255:19AM. Do you know what your validation criteria are?, by Henry de Valence, https://hdevalence.ca/blog/2020-10-04-its-25519am↩
eddsa: Taming the Many EdDSAs, by Konstantinos Chalkias, François Garillot, Valeria Nikolaenko, in SSR 2020, https://dl.acm.org/doi/abs/10.1007/978-3-030-64357-7_4↩
bulletproofs: Bulletproofs: Short Proofs for Confidential Transactions and More; by B. Bünz and J. Bootle and D. Boneh and A. Poelstra and P. Wuille and G. Maxwell; in 2018 IEEE Symposium on Security and Privacy↩
groth16: On the Size of Pairing-Based Non-interactive Arguments; by Groth, Jens; in EUROCRYPT 2016↩
tlock: tlock: Practical Timelock Encryption from Threshold BLS; by Nicolas Gailly and Kelsey Melissaris and Yolan Romailler; https://eprint.iacr.org/2023/189↩

Aptos Standards
Standards define a common interoperable interface for all developers to build upon. They consist of rules to ensure compatibility across applications and wallets on the Aptos blockchain. See a list of known coin resource addresses in Aptos provided by hippospace.

Move Standard
Aptos Object
The Object model allows Move to represent a complex type as a set of resources stored within a single address and offers a rich capability model that allows for fine-grained resource control and ownership management.

Asset Standards
Digital Asset (DA)
The new Aptos Digital Asset Standard allows:

Rich, flexible assets and collectibles.
Easy enhancement of base functionality to provide richer custom functionalities. An example of this is the aptos_token module
Digital Asset (DA) is recommended for any new collections or protocols that want to build NFT or semi-fungible tokens.

Fungible Asset (FA)
The new Aptos Fungible Asset Standard is a standard meant for simple, typesafe, and fungible assets based on object model intending to replace Aptos coin. Fungible Asset (FA) offers more features and flexibilities to Aptos move developers on creating and managing fungible assets.

Wallet Standard
Aptos Wallet
The Wallet standard ensures that all wallets use the same functionality for key features. This includes:

The same mnemonic so that wallets can be moved between providers.
Wallet adapter so that all applications can interact seamlessly with a common interface.
Legacy Standards
Aptos Token
The old existing Token module, on the other hand:

Encapsulates rich, flexible assets and collectibles. These assets are discrete (non-decimal) and can be fungible, semi-fungible, or nonfungible.
The token standard is in its own AptosToken package at the Address 0x3 to allow for rapid iteration based on feedback from the community.
Aptos Coin
The Coin module is a lightweight standard meant for simple, typesafe, and fungible assets. The coin standard is separated out into its own Move module to ensure that:

Applications and users can create and use simple tokens, with high performance and low gas overhead.
The Coin standard is part of the Aptos core framework so it can be used for currencies, including the gas currency.

Object
The Object model allows Move to represent a complex type as a set of resources stored within a single address and offers a rich capability model that allows for fine-grained resource control and ownership management.

In the object model, an NFT or token can place common token data within a Token resource, object data within an ObjectCore resource, and then specialize into additional resources as necessary. For example, a Player object could define a player within a game and be an NFT at the same time. The ObjectCore itself stores both the address of the current owner and the appropriate data for creating event streams.

Comparison with the account resources model
The existing Aptos data model emphasizes the use of the store ability within Move. Store allows for a struct to exist within any struct that is stored on-chain. As a result, data can live anywhere within any struct and at any address. While this provides great flexibility it has many limitations:

Data is not be guaranteed to be accessible, for example, it can be placed within a user-defined resource that may violate expectations for that data, e.g., a creator attempting to burn an NFT put into a user-defined store. This can be confusing to both the users and creators of this data.
Data of differing types can be stored to a single data structure (e.g., map, vector) via any, but for complex data types any incurs additional costs within Move as each access requires deserialization. It also can lead to confusion if API developers expect that a specific any field changes the type it represents.
While resource accounts allow for greater autonomy of data, they do so inefficiently for objects and do not take advantage of resource groups.
Data cannot be recursively composable, because Move currently prohibits recursive data structures. Furthermore, experience suggests that true recursive data structures can lead to security vulnerabilities.
Existing data cannot be easily referenced from entry functions, for example, supporting string validation requires many lines of code. Attempting to make tables directly becomes impractical as keys can be composed of many types, thus specializing to support within entry functions becomes complex.
Events cannot be emitted from data but from an account that may not be associated with the data.
Transferring logic is limited to the APIs provided in the respective modules and generally requires loading resources on both the sender and receiver adding unnecessary cost overheads.
TIP
Object is a core primitive in Aptos Move and created via the object module at 0x1::object

Structure
An object is stored in the ObjectGroup resource group, which enables other resources within the object to be co-located for data locality and data cost savings. It's important to note that not all resources within an object need to be co-located within the ObjectGroup, and it's up to the developer of an object to determine their data layout.

Object resource group
Object is a container for resources that are stored within a single address. These resources usually represent related data often accessed together and should be stored within a single address for data locality and cost savings. When created, an object has a resource group, ObjectGroup, by default:

#[resource_group(scope = global)]
struct ObjectGroup { }

Each object also has the core ObjectCore resource with fundamental properties:

#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct ObjectCore has key {
    /// Used by guid to guarantee globally unique objects and create event streams
    guid_creation_num: u64,
    /// The address (object or account) that owns this object
    owner: address,
    /// Object transferring is a common operation, this allows for disabling and enabling
    /// transfers. Bypassing the use of a the TransferRef.
    allow_ungated_transfer: bool,
    /// Emitted events upon transferring of ownership.
    transfer_events: event::EventHandle<TransferEvent>,
}

After creating an object, creators can extend with additional resources. For example, an exchange can create an object for each of its liquidity pools and add a resource to track the pool's liquidity.

#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct LiquidityPool has key {
    token_a: Object<FungibleAsset>,
    token_b: Object<FungibleAsset>,
    reserves_a: u128,
    reserves_b: u128
}

In the above code, token_a and token_b are references to other objects. Specifically, Object<T> is a reference to an object stored at a given address that contains T resource. In this example, they're fungible assets (similar to coins). This is covered in more detail in the Aptos Fungible Asset Standard. LiquidityPool resource is part of the ObjectGroup resource group. This means that the LiquidityPool resource is stored in the same storage slot as the ObjectCore resource. This is more storage and gas efficient for reading and writing data.

LiquidityPool resource can be added during construction of the object:

use aptos_framework::object::{Self, Object};
use aptos_framework::fungible_asset::FungibleAsset;

public fun create_liquidity_pool(
    token_a: Object<FungibleAsset>,
    token_b: Object<FungibleAsset>,
    reserves_a: u128,
    reserves_b: u128
): Object<LiquidityPool> {
    let exchange_signer = &get_exchange_signer();
    let liquidity_pool_constructor_ref = &object::create_object_from_account(exchange_signer);
    let liquidity_pool_signer = &object::generate_signer(liquidity_pool_constructor_ref);
    move_to(liquidity_pool_signer, LiquidityPool {
        token_a: token_a,
        token_b: token_b,
        reserves_a: reserves_a,
        reserves_b: reserves_b
    });
    object::object_from_constructor_ref(liquidity_pool_constructor_ref)
}

More resources can also be added post-creation if the exchange module stores the ExtendRef. This is covered in more detail in the Capabilities section.

Object Lifecycle
Creation
Objects can be created via several different functions provided in the object module:

/// Create a new named object and return the ConstructorRef. Named objects can be queried globally
/// by knowing the user generated seed used to create them. Named objects cannot be deleted.
public fun create_named_object(creator: &signer, seed: vector<u8>): ConstructorRef;

/// Create a new object from a GUID generated by an account.
public fun create_object_from_account(creator: &signer): ConstructorRef;

/// Create a new object from a GUID generated by an object.
public fun create_object_from_object(creator: &signer): ConstructorRef;

These functions generate object addresses in different schemas:

create_named_object generates an address from the caller-provided seed and creator address. This is a deterministic address that can be queried globally. The formula used is sha3(creator address + seed + 0xFD).
create_object_from_account generates an address from the caller's address and a GUID generated by the caller's account. The formula used is sha3(creator address + account guid + 0xFD).
create_object_from_object generates an address from the caller's address and a GUID generated by the caller's object. The formula used is sha3(creator address + object guid + 0xFD). The domain separation ensures there's no conflict among objects created via these different functions.
Note that since named objects have deterministic addresses, they cannot be deleted. This is to prevent a malicious user from creating an object with the same seed as a named object and deleting it.

Object capabilities (refs)
The object creation functions all return a transient ConstructorRef that cannot be stored. ConstructorRef allows adding resources to an object (see example from the previous section). ConstructorRef can also be used to generate the other capabilities (or "refs") that are used to manage the object:

/// Generates the DeleteRef, which can be used to remove Object from global storage.
public fun generate_delete_ref(ref: &ConstructorRef): DeleteRef;

/// Generates the ExtendRef, which can be used to add new events and resources to the object.
public fun generate_extend_ref(ref: &ConstructorRef): ExtendRef;

/// Generates the TransferRef, which can be used to manage object transfers.
public fun generate_transfer_ref(ref: &ConstructorRef): TransferRef;

/// Create a signer for the ConstructorRef
public fun generate_signer(ref: &ConstructorRef): signer;

These refs can be stored and used to manage the object.

DeleteRef can be used to delete the object:

use aptos_framework::object::{Object, DeleteRef};

struct DeleteRefStore has key {
    delete_ref: DeleteRef,
}

public fun delete_liquidity_pool(liquidity_pool: Object<LiquidityPool>) {
    let liquidity_pool_address = object::object_address(liquidity_pool);
    // Remove all resources added to the liquidity pool object.
    let LiquidityPool {
        token_a: _,
        token_b: _,
        reserves_a: _,
        reserves_b: _
    } = move_from<LiquidityPool>(liquidity_pool_address);
    let DeleteRefStore { delete_ref } = move_from<DeleteRefStore>(liquidity_pool_address);
    // Delete the object itself.
    object::delete_object(delete_ref);
}

ExtendRef can be used to add resources to the object like the LiquidityPool resource in the previous section: TransferRef can be used to disable owner-transfer when ungated_transfer_allowed = true or to forcefully transfer the object without the owner being involved:

use aptos_framework::object::{Object, TransferRef};

struct TransferRefStore has key {
    transfer_ref: TransferRef,
}

public fun disable_owner_transfer(liquidity_pool: Object<LiquidityPool>) {
    let liquidity_pool_address = object::object_address(liquidity_pool);
    let transfer_ref = &borrow_global_mut<TransferRefStore>(liquidity_pool_address).transfer_ref;
    object::disable_ungated_transfer(transfer_ref);
}

public fun creator_transfer(liquidity_pool: Object<LiquidityPool>, new_owner: address) {
    let liquidity_pool_address = object::object_address(liquidity_pool);
    let transfer_ref = &borrow_global_mut<TransferRefStore>(liquidity_pool_address).transfer_ref;
    object::transfer_with_ref(object::generate_linear_transfer_ref(transfer_ref), new_owner);
}

Once the resources have been created on an object, they can be modified by the creator modules without the refs/ Example:

public entry fun modify_reserves(liquidity_pool: Object<LiquidityPool>) {
    let liquidity_pool = &mut borrow_global_mut<LiquidityPool>(liquidity_pool);
    liquidity_pool.reserves_a = liquidity_pool.reserves_a + 1000;
}

Object reference
A reference to the object can be generated any time and stored in a resource as part of an object or account:

/// Returns the address of within a ConstructorRef
public fun object_from_constructor_ref<T: key>(ref: &ConstructorRef): Object<T>;

Object<T> is a reference around the object address with the guarantee that T exists when the reference is created. For example, we can create an Object<LiquidityPool> for a liquidity pool object. Creating an object reference with a non-existent T will fail at runtime. Note that after references are created and stored, they do not guarantee that the resource T or the entire object itself has not been deleted.

Events
Objects come with transfer_events by default, which are emitted when the object is transferred. Transfer events are stored in the ObjectCore resource.

Additionally, similar to account resources, events can be added in an object' resources. The object module offers the following functions to create event handles for objects:

/// Create a guid for the object, typically used for events
public fun create_guid(object: &signer): guid::GUID;

/// Generate a new event handle.
public fun new_event_handle<T: drop + store>(object: &signer): event::EventHandle<T>;

These event handles can be stored in the custom resources added to the object. Example:

struct LiquidityPoolEventStore has key {
    create_events: event::EventHandle<CreateLiquidtyPoolEvent>,
}

struct CreateLiquidtyPoolEvent {
    token_a: address,
    token_b: address,
    reserves_a: u128,
    reserves_b: u128,
}

public entry fun create_liquidity_pool_with_events() {
    let exchange_signer = &get_exchange_signer();
    let liquidity_pool_constructor_ref = &object::create_object_from_account(exchange_signer);
    let liquidity_pool_signer = &object::generate_signer(liquidity_pool_constructor_ref);
    let event_handle = object::new_event_handle<CreateLiquidtyPoolEvent>(liquidity_pool_signer);
    event::emit<CreateLiquidtyPoolEvent>(event_handle, CreateLiquidtyPoolEvent {
        token_a: token_a,
        token_b: token_b,
        reserves_a: reserves_a,
        reserves_b: reserves_b,
    });
    let liquidity_pool = move_to(liquidity_pool_signer, LiquidityPool {
        token_a: token_a,
        token_b: token_b,
        reserves_a: reserves_a,
        reserves_b: reserves_b,
        create_events: event_handle,
    });
}

Aptos Coin (Legacy)
Coin provides a standard, typesafe framework for simple, fungible tokens or coins.

TIP
Coin is stored in 0x1::coin.

Structures
Reusability
A coin is defined in Move as:

struct Coin<phantom CoinType> has store {
    /// Amount of coin this address has.
    value: u64,
}

A Coin uses the CoinType to support re-usability of the Coin framework for distinct Coins. For example, Coin<A> and Coin<B> are two distinct coins.

Global store
Coin also supports a resource for storing coins in global store:

struct CoinStore<phantom CoinType> has key {
    coin: Coin<CoinType>,
    frozen: bool,
    deposit_events: EventHandle<DepositEvent>,
    withdraw_events: EventHandle<WithdrawEvent>,
}

Coin information or metadata is stored in global store under the coin creators account:

struct CoinInfo<phantom CoinType> has key {
    name: string::String,
    /// Symbol of the coin, usually a shorter version of the name.
    /// For example, Singapore Dollar is SGD.
    symbol: string::String,
    /// Number of decimals used to get its user representation.
    /// For example, if `decimals` equals `2`, a balance of `505` coins should
    /// be displayed to a user as `5.05` (`505 / 10 ** 2`).
    decimals: u8,
    /// Amount of this coin type in existence.
    supply: Option<OptionalAggregator>,
}

Primitives
Coin provides the primitives for users creating and managing the coin and the users who use it.

Creators
Coin creators and managers can:

Initialize a coin and set its metadata and supply monitoring.
Minting and burning Coin value.
Burning coins from a CoinStore.
Freezing mobility into and out of a CoinStore.
Users
Coin users can:

Merging two Coin structs of the same type.
Extracting value from a Coin struct into a new Coin struct.
Ability to deposit and withdraw from a CoinStore and emit events as a result.
Allows for users to register a CoinStore<CoinType> in their account to handle coin.
Coin module key struct
The following tables describe fields at the struct level. For the definitive list, see the Aptos Framework containing coin.

Coin
Field	Type	Description
value	u64	Value of the token, eg: 1000000000
CoinInfo
Field	Type	Description
name	String	Name of the token, eg: Aptos Coin
symbol	String	Symbol for the token, eg: APT
decimals	u8	Determines how the value of coin is represented; for example APT’s decimal is 8, so a value of 100000000 is represented by 1 APT
supply	Option<OptionalAggregator>	option::some(optional_aggregator::new(MAX_U128, parallelizable))
Creating a new CoinType
A coin creator can publish to an on-chain account a new module that defines a struct to represent a new CoinType. The coin creator will then call coin:initialize<CoinType> from that account to register this as a valid coin, and in return receive back structs that enable calling the functions to burn and mint coins and freeze CoinStores. These will need to be stored in global storage by the creator to manage the use of the coin.

public fun initialize<CoinType>(
    account: &signer,
    name: string::String,
    symbol: string::String,
    decimals: u8,
    monitor_supply: bool,
): (BurnCapability<CoinType>, FreezeCapability<CoinType>, MintCapability<CoinType>) {

The creator has the opportunity to define a name, symbol, decimals, and whether or not the total supply for the coin is monitored. The following applies:

The first three of the above (name, symbol, decimals) are purely metadata and have no impact for on-chain applications. Some applications may use decimal to equate a single Coin from fractional coin.
Monitoring supply (monitor_supply) helps track total coins in supply. However, due to the way the parallel executor works, turning on this option will prevent any parallel execution of mint and burn. If the coin will be regularly minted or burned, consider disabling monitor_supply.
Minting Coins
If the creator or manager would like to mint coins, they must retrieve a reference to their MintCapability, which was produced in the initialize, and call:

public fun mint<CoinType>(
    amount: u64,
    _cap: &MintCapability<CoinType>,
): Coin<CoinType> acquires CoinInfo {

This will produce a new Coin struct containing a value as dictated by the amount. If supply is tracked, then it will also be adjusted.

Burning Coins
If the creator or manager would like to burn coins, they must retrieve a reference to their BurnCapability, which was produced in the initialize, and call:

public fun burn<CoinType>(
    coin: Coin<CoinType>,
    _cap: &BurnCapability<CoinType>,
) acquires CoinInfo {

The creator or manager can also burn coins from a CoinStore:

public fun burn_from<CoinType>(
    account_addr: address,
    amount: u64,
    burn_cap: &BurnCapability<CoinType>,
) acquires CoinInfo, CoinStore {

BURN VS BURN_FROM
The function burn eliminates the total value stored in the coin, while burn_from only eliminates a given amount of value from a CoinStore. If supply is tracked, then it will also be adjusted.

Burning coins from an account does not emit a WithdrawEvent as the withdraw function does.

Freezing Accounts
If the creator or manager would like to freeze a CoinStore on a specific account, they must retrieve a reference to their FreezeCapability, which was produced in initialize, and call:

public entry fun freeze_coin_store<CoinType>(
    account_addr: address,
    _freeze_cap: &FreezeCapability<CoinType>,
) acquires CoinStore {

Merging Coins
Two coins of the same type can be merged into a single Coin struct that represents the accumulated value of the two coins independently by calling:

public fun merge<CoinType>(
    dst_coin: &mut Coin<CoinType>,
    source_coin: Coin<CoinType>,
) {

Extracting Coins
A Coin can have value deducted to create another Coin by calling:

public fun extract<CoinType>(
        coin: &mut Coin<CoinType>,
        amount: u64,
): Coin<CoinType> {

Withdrawing Coins from CoinStore
A holder of a CoinStore can extract a Coin of a specified value by calling:

public fun withdraw<CoinType>(
    account: &signer,
    amount: u64,
): Coin<CoinType> acquires CoinStore {

TIP
This function will emit a WithdrawEvent.

Depositing Coins into CoinStore
Any entity can deposit coins into an account’s CoinStore by calling:

public fun deposit<CoinType>(
        account_addr: address,
        coin: Coin<CoinType>,
) acquires CoinStore {

TIP
This function will emit a DepositEvent.

Transferring Coins
A holder of a CoinStore can directly transfer coins from their account to another account’s CoinStore by calling:

public entry fun transfer<CoinType>(
    from: &signer,
    to: address,
    amount: u64,
) acquires CoinStore {

TIP
This will emit both a WithdrawEvent and DepositEvent on the respective CoinStores.

Events
struct DepositEvent has drop, store {
    amount: u64,
}

struct WithdrawEvent has drop, store {
    amount: u64,
}

Aptos Fungible Asset Standard
The Aptos Fungible Asset Standard (also known as Fungible Asset or FA) is a core framework component within Aptos that enables the tokenization of various assets, including commodities, real estate, and financial instruments. This standard facilitates the creation of decentralized financial applications.

The tokenization of securities and commodities provides fractional ownership, making these markets more accessible to a broader range of investors. Fungible tokens can also represent real estate ownership, enabling fractional ownership and providing liquidity to a traditionally illiquid market. In-game assets such as virtual currencies and characters can be tokenized, enabling players to own and trade their assets and creating new revenue streams for game developers and players.

Besides the aforementioned features, Fungible Asset (FA) is a superset of cryptocurrency, as coin is just one type of Fungible Asset. The Fungible Asset framework could replace the coin module in Move.

The Fungible Asset module provides a standard, type-safe framework for defining FAs within the Aptos Move ecosystem.

The standard is built upon Aptos object model, so all the resources defined here are included in the object resource group and stored inside objects. There are two types of objects related to FA:

Object<Metadata>: include information about the FA, such as name, symbol, and decimals.
Object<FungibleStore>: store a specific amount of FA units. FAs are units that are interchangeable with others of the same metadata. They can be stored in objects that contain a FungibleStore resource. These store objects can be freely created, and FAs can be moved, split, and combined between them easily.
The standard also supports minting new units and burning existing units with appropriate controls.

The different objects involved - Object<Metadata> and Object<FungibleStore> objects, and their relationships to accounts are shown in the diagram below:

fungible asset architecture
Difference with Aptos Coin
FA is a broader category than just coins. While fungible coins are just one possible use case of FA, it can represent a wider range of fungible items, such as in-game assets like gems or rocks, event tickets, and partial ownership of real-world assets. FA provides the flexibility for customizable, detailed management and offers a new programming model based on objects. For Aptos coin, a Coin uses a generic, or the CoinType, to support distinct typing within the Coin framework. For example, Coin<A> and Coin<B> are two distinct coins, if A != B. In contrast, FA does not have a generic in struct definition but uses the metadata reference to distinguish the type, which will be further explained later. Minimally, Aptos coin should be interchangeable with FA. The migration plan is under discussion.

Structures
Metadata Object
Metadata objects with unique addresses define the type of the FAs. Even if Metadata structs of two Object<Metadata> are exactly the same, as long as their addresses are different, the FAs points to them would be different. In short, the address of the metadata object can be used as unique identifier of the FA type.

#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct Metadata has key {
    supply: Option<Supply>,
    /// Name of the fungible metadata, i.e., "USDT".
    name: String,
    /// Symbol of the fungible metadata, usually a shorter version of the name.
    /// For example, Singapore Dollar is SGD.
    symbol: String,
    /// Number of decimals used for display purposes.
    /// For example, if `decimals` equals `2`, a balance of `505` coins should
    /// be displayed to a user as `5.05` (`505 / 10 ** 2`).
    decimals: u8,
}

Fungible Asset and Fungible Store
FA allows typing by allocating an object reference that points to the metadata. Hence, a set of units of FA is represented as an amount and a reference to the metadata, as shown:

struct FungibleAsset {
    metadata: Object<Metadata>,
    amount: u64,
}

The FAs is a struct representing the type and the amount of units held. As the struct does not have either key or store abilities, it can only be passed from one function to another but must be consumed by the end of a transaction. Specifically, it must be deposited back into a fungible store at the end of the transaction, which is defined as:

#[resource_group_member(group = aptos_framework::object::ObjectGroup)]
struct FungibleStore has key {
    /// The address of the base metadata object.
    metadata: Object<Metadata>,
    /// The balance of the fungible metadata.
    balance: u64,
    /// FAs transferring is a common operation, this allows for freezing/unfreezing accounts.
    frozen: bool,
}

TIP
FAs are always stored in the top-level FungibleStore resource. This makes it much easier to find, analyze, and control.

The only extra field added here is frozen. if it is true, this object is frozen, i.e., deposit and withdraw are both disabled without using TransferRef in the next section.

References
Reference (ref) is the means to implement granular permission control across different standards in Aptos. In different contexts, it may be called capabilities. The FA standard has three distinct refs for minting, transferring, and burning FA: MintRef, TransferRef, and BurnRef. Each ref contains a reference to the FA metadata:

struct MintRef has drop, store {
    metadata: Object<Metadata>
}

struct TransferRef has drop, store {
    metadata: Object<Metadata>
}

struct BurnRef has drop, store {
    metadata: Object<Metadata>
}

Ref owners can do the following operations depending on the refs they own:

MintRef offers the capability to mint new FA units.
TransferRef offers the capability to mutate the value of freeze in any FungbibleStore of the same metadata or transfer FA by ignoring freeze.
BurnRef offers the capability to burn or delete FA units.
The three refs collectively act as the building blocks of various permission control systems as they have store so can be passed around and stored anywhere. Please refer to the source file for mint(), mint_to(), burn(), burn_from(), withdraw_with_ref(), deposit_with_ref(), and transfer_with_ref(): These functions are used to mint, burn, withdraw, deposit, and transfer FA using the MintRef, BurnRef, and TransferRef.

Note, these are framework functions and must be combined with business logic to produce a usable system. Developers who want to use these functions should familiarize themselves with the concepts of Aptos object model and understand how the reference system enables extensible designs within Aptos move.

Creators
A Fungible Asset creator can add fungibility to any undeletable object at creation by taking &ConstructorRef with the required information to make that object a metadata of the associated FA. Then FA of this metadata can be minted and used. It is noted here that undeletable means the can_delete field of &ConstructorRef has to be false.

public fun add_fungibility(
    constructor_ref: &ConstructorRef,
    maximum_supply: Option<u128>,
    name: String,
    symbol: String,
    decimals: u8,
    icon_uri: String,
    project_uri: String,
): Object<Metadata> 

The creator has the opportunity to define a name, symbol, decimals, icon uri, project uri, and whether the total supply for the FA has a maximum. The following applies:

The first three of the above (name, symbol, decimals, icon_uri, project_uri) are purely metadata and have no impact for onchain applications. Some applications may use decimals to equate a single Coin from a fractional coin.
Maximum supply (maximum_supply) helps check the total supply does not exceed a maximum value. However, due to the way the parallel executor works, setting the maximum supply will prevent any parallel execution of mint and burn.
Users
Users are FA holders, who can:

Merge two FAs of the same metadata object.
Extract FA partially from another.
Deposit to and withdraw from a FungibleStore and emit events as a result.
Primitives
At creation, the creator has the option to generate refs from the same &ConstructorRef to manage FA. These will need to be stored in global storage to be used later.

Mint
If the manager would like to mint FA, they must retrieve a reference to MintRef and call:

public fun mint(ref: &MintRef, amount: u64): FungibleAsset

This will produce a new FA of the metadata in the ref, containing a value as dictated by the amount. The supply will also be adjusted. Also, there is a mint_to function that deposits to a FungibleStore after minting as a helper.

Burn
The opposite operation of minting. Likewise, a reference to BurnRef is required and call:

public fun burn(ref: &BurnRef, fa: FungibleAsset)

This will reduce the passed-in fa to ashes and adjust the supply. There is also a burn_from function that forcibly withdraws FA from an account first and then burns the withdrawn FA as a helper.

Transfer and Freeze/Unfreeze
TransferRef has two functions:

Flip frozen in FungibleStore holding FA of the same metadata in the TransferRef. if it is false, the store is "frozen" that nobody can deposit to or withdraw from this store without using the ref.
Withdraw from or deposit to a store ignoring frozen field.
To change frozen, call:

public fun set_frozen_flag<T: key>(
    ref: &TransferRef,
    store: Object<T>,
    frozen: bool,
)

TIP
This function will emit a FrozenEvent.

To forcibly withdraw, call:

public fun withdraw_with_ref<T: key>(
    ref: &TransferRef,
    store: Object<T>,
    amount: u64
): FungibleAsset

TIP
This function will emit a WithdrawEvent.

To forcibly deposit, call:

public fun deposit_with_ref<T: key>(
    ref: &TransferRef,
    store: Object<T>,
    fa: FungibleAsset
)

TIP
This function will emit a DepositEvent.

There is a function named transfer_with_ref that combining withdraw_with_ref and deposit_with_ref together as a helper.

Merging Fungible Assets
Two FAs of the same type can be merged into a single struct that represents the accumulated value of the two
independently by calling:

public fun merge(dst_fungible_asset: &mut FungibleAsset, src_fungible_asset: FungibleAsset)

After merging, dst_fungible_asset will have all the amounts.

Extracting Fungible Asset
A Fungible Asset can have amount deducted to create another FA by calling:

public fun extract(fungible_asset:& mut FungibleAsset, amount: u64): FungibleAsset

TIP
This function may produce FA with 0 amount, which is not usable. It is supposed to be merged with other FA or destroyed through destroy_zero() in the module.

Withdraw
The owner of a FungibleStore object that is not frozen can extract FA with a specified amount, by calling:

public fun withdraw<T: key>(owner: &signer, store: Object<T>, amount: u64): FungibleAsset

TIP
This function will emit a WithdrawEvent.

Deposit
Any entity can deposit FA into a FungibleStore object that is not frozen, by calling:

public fun deposit<T: key>(store: Object<T>, fa: FungibleAsset)

TIP
This function will emit a DepositEvent.

Transfer
The owner of a FungibleStore can directly transfer FA from that store to another if neither is frozen by calling:

public entry fun transfer<T: key>(sender: &signer, from: Object<T>, to: Object<T>, amount: u64)

TIP
This will emit both WithdrawEvent and DepositEvent on the respective Fungibletores.

Events
DepositEvent: Emitted when FAs are deposited into a store.
WithdrawEvent: Emitted when FAs are withdrawn from a store.
FrozenEvent: Emitted when the frozen status of a fungible store is updated.
struct DepositEvent has drop, store {
    amount: u64,
}

struct WithdrawEvent has drop, store {
    amount: u64,
}

struct FrozenEvent has drop, store {
    frozen: bool,
}

Primary and secondary FungibleStores
Each FungibleStore object has an owner. However, an owner may possess more than one store. When Alice sends FA to Bob, how does she determine the correct destination? Additionally, what happens if Bob doesn't have a store yet?

To address these questions, the standard has been expanded to define primary and secondary stores.

Each account owns only one undeletable primary store for each type of FA, the address of which is derived in a deterministic manner from the account address and metadata object address. If primary store does not exist, it will be created if FA is going to be deposited by calling functions defined in primary_fungible_store.move
Secondary stores do not have deterministic addresses and are theoretically deletable. Users are able to create as many secondary stores as they want using the provided functions but there is a caveat that addressing secondary stores on-chain may need extra work.
The vast majority of users will have primary store as their only store for a specific type of FAs. It is expected that secondary stores would be useful in complicated defi or other asset management contracts that will be introduced in other tutorials using FA.

How to enable Primary FungibleStore?
To add primary store support, when creating a metadata object, instead of the aforementioned add_fungibility(), the creator has to call:

public fun create_primary_store_enabled_fungible_asset(
    constructor_ref: &ConstructorRef,
    maximum_supply: Option<u128>,
    name: String,
    symbol: String,
    decimals: u8,
    icon_uri: String,
    project_uri: String,
) 

The parameters are the same as those of add_fungibility().

Primitives
Get Primary FungibleStore
To get the primary store object of a metadata object belonging to an account, call:

public fun primary_store<T: key>(owner: address, metadata: Object<T>): Object<FungibleStore>

TIP
There are other utility functions. primary_store_address returns the deterministic address the primary store, and primary_store_exists checks the existence, etc.

Manually Create Primary FungibleStore
If a primary store does not exist, any entity is able to create it by calling:

public fun create_primary_store<T: key>(owner_addr: address, metadata: Object<T>): Object<FungibleStore>


Check Balance and Frozen Status
To check the balance of a primary store, call:

public fun balance<T: key>(account: address, metadata: Object<T>): u64

To check whether the given account's primary store is frozen, call:

public fun is_frozen<T: key>(account: address, metadata: Object<T>): bool

Withdraw
An owner can withdraw FA from their primary store by calling:

public fun withdraw<T: key>(owner: &signer, metadata: Object<T>, amount: u64): FungibleAsset

Deposit
An owner can deposit FA to their primary store by calling:

public fun deposit(owner: address, fa: FungibleAsset)

Transfer
An owner can deposit FA from their primary store to that of another account by calling:

public entry fun transfer<T: key>(sender: &signer, metadata: Object<T>, recipient: address, amount: u64)


Secondary FungibleStore
Secondary stores are not commonly used by normal users but prevailing for smart contracts to manage assets owned by contracts. For example, an asset pool may have to manage multiple fungible stores for one or more types of FA. Those stores do not necessarily have to have deterministic addresses and a user may have multiple stores for a given kind of FA. So primary fungible store is not a good fit for the needs where secondary store plays a vital role.

The way to create secondary store is to create an object first and get its ConstructorRef. Then call:

public fun create_store<T: key>(
    constructor_ref: &ConstructorRef,
    metadata: Object<T>,
): Object<FungibleStore>

It will turn make the newly created object a FungibleStore. Sometimes an object can be reused as a store. For example, a metadata object can also be a store to hold some FA of its own type or a liquidity pool object can be a store of the issued liquidity pool's token/coin.

Ownership of FungibleStore
It is crucial to set correct owner of a FungibleStore object for managing the FA stored inside. By default, the owner of a newly created object is the creator whose signer is passed into the creation function. For FungibleStore objects managed by smart contract itself, usually they shouldn't have an owner out of the control of this contract. For those cases, those objects could make themselves as their owners and keep their object ExtendRef at the proper place to create signer as needed by the contract logic.

Aptos Digital Asset Standard
Overview of NFTs
An NFT is a non-fungible token or data stored on a blockchain that uniquely defines ownership of an asset. NFTs were first defined in EIP-721 and later expanded upon in EIP-1155. NFTs are typically defined using the following properties:

name: The name of the asset. It must be unique within a collection.
description: The description of the asset.
uri: A URL pointer to off-chain for more information about the asset. The asset could be media such as an image or video or more metadata.
supply: The total number of units of this NFT. Many NFTs have only a single supply, while those that have more than one are referred to as editions.
Additionally, most NFTs are part of a collection or a set of NFTs with a common attribute, for example, a theme, creator, or minimally contract. Each collection has a similar set of attributes:

name: The name of the collection. The name must be unique within the creator's account.
description: The description of the collection.
uri: A URL pointer to off-chain for more information about the asset. The asset could be media such as an image or video or more metadata.
supply: The total number of NFTs in this collection.
maximum: The maximum number of NFTs that this collection can have. If maximum is set to 0, then supply is untracked.
Design principles
The Aptos Digital Asset Standard was developed with the following as an improvement on the Aptos Token standard. It has these ideas in mind:

Flexibility - NFTs are flexible and can be customized to accommodate any creative designs.
Composability - Multiple NFTs can be easily composed together, such that the final object is greater than the sum of its parts
Scalability - Greater parallelism between tokens
The base token only provides minimal functionalities and is meant to build upon to add more functionalities. All of its functions are non-entry and thus not callable directly from off chain. Creators need to write their own modules that use these fuctionalities or use "no code" solutions also provided in the framework. One such solution is aptos_token which provides functionalities such as custom metadata (via PropertyMap) and soul bound.

Comparison to the legacy Aptos Token Standard
Digital Asset uses Aptos objects rather than account resources traditionally used in Move. This allows for storing data outside the account and adding flexibility in this way.

Tokens can be easily extended with custom data and functionalities without requiring any changes in the framework
Transfers are simply a reference update
Direct transfer is allowed without an opt in
NFTs can own other NFTs adding easy composability
Soul bound tokens can be easily supported
Collections and tokens as objects
In this Token standard, both collections and tokens will be separate objects. They have their own distinct addresses and can be referenced both on and off chain by address. Each object can contain multiple resources so collections and tokens are extensible by default, allowing the creator to add custom data and functionalities without having to modify the framework.

On chain, another struct can include a reference to the collection or token objects like below:

struct ReferenceExample has key {
    my_collection: Object<Collection>,
    my_token: Object<Token>,
}

where both my_collection and my_token are addresses (with Object<> wrapper).

Off-chain, the address of the object can be passed along to replace object arguments in entry functions called by transaction creation. as arguments. For example:

public entry fun my_function(my_collection: Object<Collection>) {
    // Do something with the collection
}

Collection and token addresses will also be used to query data such as fetching all resources via fullnode API or against an indexing service.

Royalties
Following the object extensibility pattern, royalties are added to collections or tokens as a resource with associated functionality provided by the royalty module Royalty can be updated as long as a MutatorRef, a storable struct that grants permissions, is generated at creation time and stored.

See Aptos Token for examples on how Royalty's MutatorRef can be stored and used. Royalty can also be set directly on a token if it has a different royalty config than the collection's.

Token lifecycle
All Digital Asset modules are deployed at the reserved framework address 0x4.

Collection creation
Every token belongs to a collection. The developer first needs to create a collection with:

A fixed maximum supply. Current supply is tracked and cannot exceed the maximum set.
use aptos_token_objects::collection;

public entry fun create_collection(creator: &signer) {
    let max_supply = 1000;
    collection::create_fixed_collection(
        creator,
        "My Collection Description",
        max_supply,
        "My Collection",
        royalty,
        "https://mycollection.com",
    );
}

Unlimited supply. Current supply is still tracked but there's no maximum enforced.
public entry fun create_collection(creator: &signer) {
    collection::create_unlimited_collection(
        creator,
        "My Collection Description",
        "My Collection",
        royalty,
        "https://mycollection.com",
    );
}

Note that both track the current supply. Maximum supply cannot be changed after the collection is created, and a collection cannot be converted from unlimited to fixed supply or vice versa.

A collection has the following attributes:

Collection name - unique within each account. This means a single creator account cannot create more than one collection with the same name.
Description - modifiable with a MutatorRef and smaller than 2048 characters
URI length - modifiable with a MutatorRef and smaller than 512 characters
Royalty - specifies how many % of the sale price goes to the creator of the collection. This can be changed with a MutatorRef generated by the Royalty module.
A MutatorRef, a storable struct that grants permissions to mutate, can be generated only during creation of the collection. If created, the holder of the MutatorRef can change the description and the URI length of the collection.

public entry fun create_collection(creator: &signer) {
    let collection_constructor_ref = &collection::create_unlimited_collection(
        creator,
        "My Collection Description",
        "My Collection",
        royalty,
        "https://mycollection.com",
    );
    let mutator_ref = collection::get_mutator_ref(collection_constructor_ref);
    // Store the mutator ref somewhere safe
}

Collection customization
A collection can be customized by adding more data (as resources) or functionalities. For example, a collection can track when it was created in order to limit when tokens can be minted.

struct MyCollectionMetadata has key {
    creation_timestamp_secs: u64,
}

public entry fun create_collection(creator: &signer) {
    // Constructor ref is a non-storable struct returned when creating a new object.
    // It can generate an object signer to add resources to the collection object.
    let collection_constructor_ref = &collection::create_unlimited_collection(
        creator,
        "My Collection Description",
        "My Collection",
        royalty,
        "https://mycollection.com",
    );
    // Constructor ref can be exchanged for signer to add resources to the collection object.
    let collection_signer = &object::generate_signer(collection_constructor_ref);
    move_to(collection_signer, MyCollectionMetadata { creation_timestamp_secs: timestamp::now_seconds() } })
}


Token creation
Creators can mint tokens, which are separate objects from the collection. This allows for greater customization. Tokens can be created in two ways:

Named tokens. These tokens have deterministic addresses that are sha256 hash of the creator address, collection name, and token name, concatenated. This allows for predictable addresses and easier querying of tokens. However, named tokens are fully deletable and thus burning them will only delete the token data and not fully delete the underlying object
use aptos_token_objects::token;

public entry fun mint_token(creator: &signer) {
    token::create_named_token(
        creator,
        "My Collection",
        "My named Token description",
        "My named token",
        royalty,
        "https://mycollection.com/my-named-token.jpeg",
    );
}

(Unnamed) tokens based on the creator account's guid. These tokens have addresses are generated based on the creator account's incrementing guid. The addresses of unnamed tokens are not deterministic as the account's guid can change outside minting. Thus, querying for unnamed tokens is more difficult and requires indexing.
use aptos_token_objects::token;

public entry fun mint_token(creator: &signer) {
    token::create(
        creator,
        "My Collection",
        "My named Token description",
        "My named token",
        royalty,
        "https://mycollection.com/my-named-token.jpeg",
    );
}

Creators should cautiously consider whether they should use create_named_token or create when building their custom collection/token. In general create is recommended as it allows for clean deletion if the tokens are burnt and generally, deterministic addresses for tokens are not always necessary thanks to indexing services. One example that would prefer deterministic addresses and thus create_named_token is a collection of soul bound tokens where each token's address is created from the holder's name.

Token properties
Tokens by default have the following properties:

Token name - unique within each collection. A collection cannot have more than one token with the same name.
Token description - modifiable with a MutatorRef and smaller than 2048 characters
Token URI length - modifiable with a MutatorRef and smaller than 512 characters
Royalty - It's less common to have royalty setting on the token instead of collection. But this allows a token to have a different royalty setting than the collection's.
A MutatorRef can be generated only during creation of the token.

public entry fun mint_token(creator: &signer) {
    // Constructor ref is a non-storable struct returned when creating a new object.
    // It can be exchanged for signer to add resources to the token object.
    let token_constructor_ref = &token::create(
        creator,
        "My Collection",
        "My named Token description",
        "My named token",
        royalty,
        "https://mycollection.com/my-named-token.jpeg",
    );
    let mutator_ref = token::generate_mutator_ref(token_constructor_ref);
    // Store the mutator ref somewhere safe
}

Token customization
More data can be added to the token as resources, similar to for collections.

Token burn
Tokens can be burned by the creator if they generated and stored a BurnRef during the creation of the token.

public entry fun mint_token(creator: &signer) {
    let token_constructor_ref = &token::create(
        creator,
        "My Collection",
        "My named Token description",
        "My named token",
        royalty,
        "https://mycollection.com/my-named-token.jpeg",
    );
    let burn_ref = token::generate_burn_ref(token_constructor_ref);
    // Store the burn ref somewhere safe
}

public entry fun burn_token(token: Object<Token>) {
    // Remove all custom data from the token object.
    let token_address = object::object_address(&token);
    let CustomData { ... } = move_from<CustomData>(token_address);

    // Retrieve the burn ref from storage
    let burn_ref = ...;
    token::burn(burn_ref);
}

Note that if any custom data was added to the token objects, the burn_token function needs to first remove those data. token::burn only deletes the object if it was created as an unnamed token. Named token will have all token data removed, but the object will stay, thus creating a "burned" defunct object.

Token transfer
Tokens can be simply transferred as objects to any user via object::transfer

Aptos Token
Aptos Token is a "no code" solution that builds on top of the base Aptos Digital Asset Standard and provides a more complete solution that allows creators to mint NFTs without writing any code. It provides the following main features:

Soul bound tokens which are non-transferable by holders
Custom defined properties stored in a PropertyMap, a simple map data structure of attribute name (string) -> values (bytes).
Freezing and unfreezing transfers of non-soul bound tokens
Creator management functionalities - modify a collection or token's metadata
Property Map
Similar to in Token Standard v1, Aptos Token provides an extensible PropertyMap that provides type safe, but generic properties for a given NFT. Creators can set pass initial properties when minting a token and can freely add or remove properties later.

Tokens can be minted using the provided aptos_token::mint. This is an entry function and can be called via a transaction directly.

public entry fun mint(
    creator: &signer,
    collection: String,
    description: String,
    name: String,
    uri: String,
    property_keys: vector<String>,
    property_types: vector<String>,
    property_values: vector<vector<u8>>,
    ) acquires AptosCollection, AptosToken

To mint a soul bound token, the creator can call aptos_token::mint_soul_bound instead. This will create a token that the holder cannot transfer.

public entry fun mint_soul_bound(
    creator: &signer,
    collection: String,
    description: String,
    name: String,
    uri: String,
    property_keys: vector<String>,
    property_types: vector<String>,
    property_values: vector<vector<u8>>,
    soul_bound_to: address,
) acquires AptosCollection

Creator management
By default, the creator can do the following:

Mint and burn tokens, including soul bound tokens
Disallow transferring a token (freeze) and allow transferring a token (unfreeze)
Update the collection's description and uri
Add/Remove metadata properties from a token's property map
Update a collection's royalty setting
Update a token's name, description and uri
Further customization
Aptos Token is provided as a "no code" convenient solution, but it's not extensible. This is evident as most functions are entry functions and do not return any ref (constructor, mutator, etc.). The aptos_token module stores and manages the refs obtained from creating the collection and token objects and do not expose raw access to them.

If a creator wants more custom functionalities such as being able to forcefully transfer a soul bound token, they would need to write their own custom module that builds on top of the base Aptos Digital Asset Standard. They can of course borrow inspiration and code from the Aptos Token module.

Fungible Token
Similar to EIP-1155, the Aptos Digital Asset Standard also supports fungible tokens (also known as semi-fungible tokens). An example of this would be armor tokens in a game. Each armor token represents a type of armor and is a token in a collection with metadata (e.g. durability, defense, etc.) and can be minted and burned. However, there are multiple instances of the same armor type. For example, a player can have 3 wooden armors, where wooden armor is a token in the Armor collection.

This can be easily built by creating an asset that is both a Digital Asset (DA) and a Fungible Asset (FA), resulting in a Digital and Fungible Asset (DFA). After the creator creates the Armor collection and the Wooden Armor token, they can make the Wooden Armor token "fungible":

use aptos_framework::primary_fungible_store;

public entry fun create_armor_collection(creator: &signer) {
    collection::create_unlimited_collection(
        creator,
        "Collection containing different types of armors. Each armor type is a separate token",
        "Armor",
        royalty,
        "https://myarmor.com",
    );
}

public entry fun create_armor_type(creator: &signer, armor_type: String) {
    let new_armor_type_constructor_ref = &token::create(
        creator,
        "Armor",
        "Armor description",
        armor_type,
        royalty,
        "https://myarmor.com/my-named-token.jpeg",
    );
    // Make this armor token fungible so there can multiple instances of it.
    primary_fungible_store::create_primary_store_enabled_fungible_asset(
        new_armor_type_constructor_ref,
        maximum_number_of_armors,
        armor_type,
        "ARMOR",
        0, // Armor cannot be divided so decimals is 0,
        "https://mycollection.com/armor-icon.jpeg",
        "https://myarmor.com",
    );

    // Add properties such as durability, defence, etc. to this armor token
}

Now the creator can mint multiple instances of the same armor type and transfer them to players. The players can freely transfer the armor tokens to each other the same way they would transfer a fungible asset.

Aptos Token (Legacy)
APTOS TOKEN STANDARDS COMPARED
Also see the comparison of Aptos Token standards.

Overview of NFT
An NFT is a non-fungible token or data stored on a blockchain that uniquely defines ownership of an asset. NFTs were first defined in EIP-721 and later expanded upon in EIP-1155. NFTs are typically defined using the following properties:

name: The name of the asset. It must be unique within a collection.
description: The description of the asset.
uri: A URL pointer to off-chain for more information about the asset. The asset could be media such as an image or video or more metadata.
supply: The total number of units of this NFT. Many NFTs have only a single supply, while those that have more than one are referred to as editions.
Additionally, most NFTs are part of a collection or a set of NFTs with a common attribute, for example, a theme, creator, or minimally contract. Each collection has a similar set of attributes:

name: The name of the collection. The name must be unique within the creator's account.
description: The description of the collection.
uri: A URL pointer to off-chain for more information about the asset. The asset could be media such as an image or video or more metadata.
supply: The total number of NFTs in this collection.
maximum: The maximum number of NFTs that this collection can have. If maximum is set to 0, then supply is untracked.
Design principles
The Aptos token standard is developed with the following principles:

Interoperability: Provide a standard implementation to improve interoperability across the ecosystem projects. Moreover, Move being a static language without dynamic dispatch makes this principle even more imperative.
Liquidity: Achieve maximal liquidity by defining the NFT, fungible (non-decimal) and semi-fungible tokens in one contract. These different types of tokens can be easily stored, transferred and transacted in the same way. As a consequence, it becomes easier to achieve maximal interoperability across the marketplaces, exchanges, and other methods of exchange.
Rich on-chain token properties: Enable the customization of on-chain token properties. Users can define their own properties and store them on-chain. This can potentially eliminate the need for the off-chain metadata.
Reduced overhead: Reduce the cost of creating large amounts of NFTs from fungible tokens. This can lead to, for example, reduced overhead for similar tokens by the reuse of on-chain metadata for certain fungible tokens.
FUNGIBLE TOKEN → NFT
The Aptos token standard supports mutation of a fungible token to an NFT.

Storing customized token properties on-chain
The Aptos token standard uses the PropertyMap module to store on-chain properties of tokens. PropertyMap maps a string key to a property value on-chain, which stores the value in Binary Canonical Serialization (BCS) format and its type. Currently, only primitive types (bool, u8, u64, u128, address and String) are supported in PropertyMap. Applications, such as Aptos Names, define application specific properties that are read and written by the applications smart contract.

Default properties
You can add your properties to default_properties in the TokenData. The properties defined here are shared by all tokens by default.

The default_properties field is a key-value store with type information. It leverages the PropertyMap module which contain functions for serializing and deserializing different primitive types to the property value.

Token properties
You can also use the token_properties defined in the token itself for customization on-chain. You can create customized values for a property of this specific token, thereby allowing a token to have a different property value from its default.

Note that limits exist to storing customized token properties on-chain, namely 1000 properties per token with field names limited to 128 characters.

Evolving from fungible token to NFT
Fungible tokens share the same default property values. However, these property values can evolve over time and become different from each other. To support such evolution of token properties, the Aptos token standard provides the property_version field. Here is how it works:

During the token creation (minting), all tokens initially have property_version set to 0 and these tokens can be stacked together as fungible token.
When the creators mutate the default properties of a token, the mutated token will be assigned a unique property_version to create a new token_id to differentiate it from other fungible tokens. This unique token_id allows the token to have its own property values, and all further mutation of this token does not change the property_version again. This token essentially becomes an NFT now.
Configuring mutability
To make mutability explicit for both the creator and owner, the Aptos token standard provides mutability_config at both the collection level and the token level to control which fields are mutable. Configurable here means the creator can configure this field to be mutable or immutable during creation.

Storing metadata off-chain
Follow the standard below to ensure your NFT can be correctly displayed by various wallets.

You should store the metadata in a JSON file located in an off-chain storage solution such as arweave and provide the URL to the JSON file in the uri field of the token or the collection. We recommend the developers follow the ERC-1155 off-chain data schema to format their JSON files.

{
  "image": "https://www.arweave.net/abcd5678?ext=png",
  "animation_url": "https://www.arweave.net/efgh1234?ext=mp4",
  "external_url": "https://petra.app/",
  "attributes": [
    {
      "trait_type": "web",
      "value": "yes"
    },
    {
      "trait_type": "mobile",
      "value": "yes"
    },
    {
      "trait_type": "extension",
      "value": "yes"
    }
  ],
  "properties": {
    "files": [
      {
        "uri": "https://www.arweave.net/abcd5678?ext=png",
        "type": "image/png"
      },
      {
        "uri": "https://watch.videodelivery.net/9876jkl",
        "type": "unknown",
        "cdn": true
      },
      {
        "uri": "https://www.arweave.net/efgh1234?ext=mp4",
        "type": "video/mp4"
      }
    ],
    "category": "video",
  }
}

image: URL to the image asset. You may use the ?ext={file_extension} query to provide information on the file type.
animation_url: URL to the multimedia attachment of the asset. You may use the same file_extension query to provide the file type.
external_url: URL to an external website where the user can also view the image.
attributes - Object array, where an object should contain trait_type and value fields. value can be a string or a number.
properties.files: Object array, where an object should contain the URI and type of the file that is part of the asset. The type should match the file extension. The array should also include files specified in image and animation_url fields, as well as any other files associated with the asset. You may use the ?ext={file_extension} query to provide information on the file type.
properties.category: Has supported categories:
image - PNG, GIF, JPG
video - MP4, MOV
audio - MP3, FLAC, WAV
vr - 3D models; GLB, GLTF
html - HTML pages; scripts and relative paths within the HTML page are also supported
You can also host your files on CDN to provide faster loading time by using the cdn flag in the file object. When the file exists, this should be the primary location to read the media file (video, audio, vr) by wallet. If the file is no longer available, the wallet can fall back to use the animation_url to load the file.

"properties": {
  "files": [
    ...
    {
      "uri": "https://watch.videodelivery.net/52a52c4a261c88f19d267931426c9be6",
      "type": "unknown",
      "cdn": true
    },
    ...
  ]
}

Token data model
The following diagram depicts the flow of token data through Aptos.

Signed Transaction Flow
Token resources
As shown in the diagram above, token-related data are stored at both the creator’s account and the owner’s account.

Struct-level resources
The following tables describe fields at the struct level. For the definitive list, see the Aptos Token Framework.

Resource stored at the creator’s address
Field	Description
Collections	Maintains a table called collection_data, which maps the collection name to the CollectionData. It also stores all the TokenData that this creator creates.
CollectionData	Stores the collection metadata. The supply is the number of tokens created for the current collection. The maximum is the upper bound of tokens in this collection.
CollectionMutabilityConfig	Specifies which field is mutable.
TokenData	Acts as the main struct for holding the token metadata. Properties is a where users can add their own properties that are not defined in the token data. Users can mint more tokens based on the TokenData, and those tokens share the same TokenData.
TokenMutabilityConfig	Controls which fields are mutable.
TokenDataId	An ID used for representing and querying TokenData on-chain. This ID mainly contains three fields including creator address, collection name and token name.
Royalty	Specifies the denominator and numerator for calculating the royalty fee. It also has the payee account address for depositing the royalty.
PropertyValue	Contains both value of a property and type of property.
Resource stored at the owner’s address
Field	Description
TokenStore	The main struct for storing the token owned by this address. It maps TokenId to the actual token.
Token	The amount is the number of tokens.
TokenId	TokenDataId points to the metadata of this token. The property_version represents a token with mutated PropertyMap from default_properties in the TokenData.
For more detailed descriptions, see Aptos Token Framework.

Token lifecycle
Token creation
Every Aptos token belongs to a collection. The developer first needs to create a collection through create_collection_script and then create the token belonging to the collection create_token_script. To achieve parallel TokenData and Token creation, a developer can create unlimited collection and TokenData where the maximum of the collection and TokenData are set as 0. With this setting, the token contract won’t track the supply of types of token (TokenData count) and supply of token within each token type. As the result, the TokenData and token can be created in parallel.

Aptos also enforces simple validation of the input size and prevents duplication:

Token name - unique within each collection
Collection name - unique within each account
Token and collection name length - smaller than 128 characters
URI length - smaller than 512 characters
Property map - can hold at most 1000 properties, and each key should be smaller than 128 characters
Token mutation
Our standard supports mutation with a principle that the mutable fields are specified during the token creation. This allows the token owner to be informed which fields are mutable when they get the token from the creator. Our contract uses CollectionMutabilityConfig to check if a field is mutable. Our contract uses TokenMutabilityConfig to check if a TokenData field is mutable.

For mutation of properties, we have both

default_properties stored in TokenData shared by all tokens belonging to the TokenData
token_properties stored in the token itself
To mutate default_properties, developers can use mutate_tokendata_property to mutate the properties when TokenMutabilityConfig is set to true.

CAUTION: Set the TokenMutabilityConfig field to false unless it is absolutely necessary. Allowing default_properties to be mutable provides creators too much power; creators can change the burnable config to provide themselves the authority to burn tokens after token creation.

To mutate token_properties stored in the token, our standard uses the TOKEN_PROPERTY_MUTABLE property stored in default_properties. When the creator creates the TokenData with the TOKEN_PROPERTY_MUTABLE property set to true, the creator can mutate token_properties. Note that if the mutate_tokendata_property is set to true, creators can mutate the token_properties anyway since they can overwrite the setting in default_properties.

Token burn
We provide burn and burn_by_creator functions for token owners and token creators to burn (or destroy) tokens. However, these two functions are also guarded by configs that are specified during the token creation so that both creator and owner are clear on who can burn the token. Burn is allowed only when the BURNABLE_BY_OWNER property is set to true in default_properties. Burn by creator is allowed when BURNABLE_BY_CREATOR is true in default_properties. Once all the tokens belonging to a TokenData are burned, the TokenData will be removed from the creator’s account. Similarly, if all TokenData belonging to a collection are removed, the CollectionData will be removed from the creator’s account.

Token transfer
We provide three different modes for transferring tokens between the sender and receiver.

Two-step transfer
To protect users from receiving undesired NFTs, they must be first offered NFTs, and then accept the offered NFTs. Then only the offered NFTs will be deposited in the users' token stores. This is the default token transfer behavior. For example:

If Alice wants to send Bob an NFT, she must first offer Bob this NFT. This NFT is still stored under Alice’s account.
Only when Bob claims the NFT, will the NFT be removed from Alice’s account and stored in Bob’s token store.
TOKEN TRANSFER MODULE
The token transfer is implemented in the token_transfers module.

Transfer with opt-in
If a user wants to receive direct transfer of the NFT, skipping the initial steps of offer and claim, then the user can call opt_in_direct_transfer to allow other people to directly transfer the NFTs into the user's token store. After opting into direct transfer, the user can call transfer to transfer tokens directly. For example, Alice and anyone can directly send a token to Bob's token store once Bob opts in.

TURNING OFF DIRECT TRANSFER
The user can also turn off this direct transfer behavior by calling the same opt_in_direct_transfer function to reset to the default behavior.

Multi-agent transfer
The sender and receiver can both sign a transfer transaction to directly transfer a token from the sender to receiver direct_transfer_script. For example, once Alice and Bob both sign the transfer transaction, the token will be directly transferred from Alice's account to Bob.

Aptos Wallet Standard
The wallet standard provides guidelines for interoperability between wallet types. This ensures dapp developers do not need to change their applications to handle different wallets. This standard offers a single interface for all dapp developers, allowing easy additions of new wallets and more users to each application. This interoperability allows users to choose which wallet they want without worrying about whether apps support their use cases.

In order to ensure interoperability across Aptos wallets, the following is required:

Mnemonics - a set of words that can be used to derive account private keys
dapp API - entry points into the wallet to support access to identity managed by the wallet
Key rotation - the feature handling both the relationship around mnemonics and the recovery of accounts in different wallets
Mnemonics phrases
A mnemonic phrase is a multiple word phrase that can be used to generate account addresses. We recommend one mnemonic per account in order to handle key rotation better. However, some wallets may want to support one mnemonic to many accounts coming from other chains. To support both of these use cases, the Aptos wallet standard uses a Bitcoin Improvement Proposal (BIP44) to derive path for mnemonics to accounts.

Creating an Aptos account
Aptos account creation can be supported across wallets in the following manner:

Generate a mnemonic phrase, for example with BIP39.
Get the master seed from that mnemonic phrase.
Use the BIP44-derived path to retrieve an account address (e.g. m/44'/637'/0'/0'/0')
See the Aptos TypeScript SDK's implementation for the derive path)
For example, Petra Wallet always uses the path m/44'/637'/0'/0'/0' since there is one mnemonic per one account.
/**
   * Creates new account with bip44 path and mnemonics,
   * @param path. (e.g. m/44'/637'/0'/0'/0')
   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
   * @param mnemonics.
   * @returns AptosAccount
   */
  static fromDerivePath(path: string, mnemonics: string): AptosAccount {
    if (!AptosAccount.isValidPath(path)) {
      throw new Error("Invalid derivation path");
    }

    const normalizeMnemonics = mnemonics
      .trim()
      .split(/\s+/)
      .map((part) => part.toLowerCase())
      .join(" ");

    const { key } = derivePath(path, bytesToHex(bip39.mnemonicToSeedSync(normalizeMnemonics)));

    return new AptosAccount(new Uint8Array(key));
  }

Supporting one mnemonic per multiple account wallets
This is not recommended because the one-mnemonic-to-many-accounts paradigm makes it harder to handle rotated keys (the mnemonic changes for one account but not others). However, many wallets from other ecosystems use this paradigm, and take these steps to generate accounts

Generate a mnemonic phrase, for example with BIP39.
Get the master seed from that mnemonic phrase.
Use the BIP44-derived path to retrieve private keys (e.g. m/44'/637'/i'/0'/0') where i is the account index.
See the Aptos TypeScript SDK's implementation for the derive path)
Increase i until all of the accounts the user wants to import are found.
Note: The iteration should be limited, if an account doesn't exist during iteration, keep iterating for a constant address_gap_limit (10 for now) to see if there are any other accounts. If an account is found we will continue to iterate as normal.
ie.

const gapLimit = 10;
let currentGap = 0;

for (let i = 0; currentGap < gapLimit; i += 1) {
    const derivationPath = `m/44'/637'/${i}'/0'/0'`;
    const account = fromDerivePath(derivationPath, mnemonic);
    const response = account.getResources();
    if (response.status !== 404) {
        wallet.addAccount(account);
        currentGap = 0;
    } else {
        currentGap += 1;
    }
}

dapp API
More important than account creation, is how wallets connect to dapps. Additionally, following these APIs will allow for the wallet developer to integrate with the Aptos Wallet Adapter Standard. The APIs are as follows:

connect(), disconnect()
account()
network()
signAndSubmitTransaction(transaction: EntryFunctionPayload)
signMessage(payload: SignMessagePayload)
Event listening (onAccountChanged(listener), onNetworkChanged(listener))
// Common Args and Responses

// For single-signer account, there is one publicKey and minKeysRequired is null.
// For multi-signer account, there are multiple publicKeys and minKeysRequired value.
type AccountInfo {
    address: string;
    publicKey: string | string[];
    minKeysRequired?: number; // for multi-signer account
}

type NetworkInfo = {
  name: string;
  chainId: string;
  url: string;
};

// The important thing to return here is the transaction hash, the dApp can wait for it
type [PendingTransaction](https://github.com/aptos-labs/aptos-core/blob/1bc5fd1f5eeaebd2ef291ac741c0f5d6f75ddaef/ecosystem/typescript/sdk/src/generated/models/PendingTransaction.ts)

type [EntryFunctionPayload](https://github.com/aptos-labs/aptos-core/blob/1bc5fd1f5eeaebd2ef291ac741c0f5d6f75ddaef/ecosystem/typescript/sdk/src/generated/models/EntryFunctionPayload.ts)




Connection APIs
The connection APIs ensure that wallets don't accept requests until the user acknowledges that they want to see the requests. This keeps the user state clean and prevents the user from unknowingly having prompts.

connect() will prompt the user for a connection
return Promise<AccountInfo>
disconnect() allows the user to stop giving access to a dapp and also helps the dapp with state management
return Promise<void>
State APIs
Get Account
Connection required

Allows a dapp to query for the current connected account address and public key

account() no prompt to the user
returns Promise<AccountInfo>
Get Network
Connection required

Allows a dapp to query for the current connected network name, chain ID, and URL

network() no prompt to the user
returns Promise<NetworkInfo>
Signing APIs
Sign and submit transaction
Connection required

Allows a dapp to send a simple JSON payload using the TypeScript SDK for signing and submission to the current network. The user should be prompted for approval.

signAndSubmitTransaction(transaction: EntryFunctionPayload) will prompt the user with the transaction they are signing
returns Promise<PendingTransaction>
Sign message
Connection required

Allows a dapp to sign a message with their private key. The most common use case is to verify identity, but there are a few other possible use cases. The user should be prompted for approval. You may notice some wallets from other chains just provide an interface to sign arbitrary strings. This can be susceptible to man-in-the-middle attacks, signing string transactions, etc.

Types:

export interface SignMessagePayload {
  address?: boolean; // Should we include the address of the account in the message
  application?: boolean; // Should we include the domain of the dApp
  chainId?: boolean; // Should we include the current chain id the wallet is connected to
  message: string; // The message to be signed and displayed to the user
  nonce: string; // A nonce the dApp should generate
}

export interface SignMessageResponse {
  address?: string;
  application?: string;
  chainId?: number;
  fullMessage: string; // The message that was generated to sign
  message: string; // The message passed in by the user
  nonce: string,
  prefix: string, // Should always be APTOS
  signature: string | string[]; // The signed full message
  bitmap?: Uint8Array; // a 4-byte (32 bits) bit-vector of length N
}

signMessage(payload: SignMessagePayload) prompts the user with the payload.message to be signed
returns Promise<SignMessageResponse>
An example: signMessage({nonce: 1234034, message: "Welcome to dApp!", address: true, application: true, chainId: true })

This would generate the fullMessage to be signed and returned as the signature:

APTOS
address: 0x000001
chain_id: 7
application: badsite.firebase.google.com
nonce: 1234034
message: Welcome to dApp!

Aptos has support for both single-signer and multi-signer accounts. If the wallet is single-signer account, there is exactly one signature and bitmap is null. If the wallet is a multi-signer account, there are multiple signature and bitmap values. The bitmap masks that public key that has signed the message.

Event listening
To be added in the future:

Event listening (onAccountChanged(listener), onNetworkChanged(listener))
Key rotation
Key rotation is currently not implemented in any wallets. Mapping of rotated keys has been implemented, but SDK integration is in progress.

Wallets that import a private key will have to do the following:

Derive the authentication key.
Lookup the authentication key onchain in the Account origination table.
If the account doesn't exist, it's a new account. The address to be used is the authentication key.
If the account does exist, it's a rotated key account, and the address to be used will come from the table.
Appendix
Forum post with discussion about the dapp API

Use the Aptos REST Read API
If you provide blockchain services to your customers and wish to employ the Aptos API, then this guide is for you. This guide will walk you through all you need to integrate the Aptos blockchain into your platform with the Aptos API.

TIP
Also see the System Integrators Guide for a thorough walkthrough of Aptos integration.

Understanding rate limits
As with the Aptos Indexer, the Aptos REST API has a rate limit of 5000 requests per five minutes by IP address, whether submitting transactions or querying the API on Aptos-provided nodes. (As a node operator, you may raise those limits on your own node.) Note that this limit can change with or without prior notice.

Viewing current and historical state
Most integrations into the Aptos blockchain benefit from a holistic and comprehensive overview of the current and historical state of the blockchain. Aptos provides historical transactions, state, and events, all the result of transaction execution.

Historical transactions specify the execution status, output, and tie to related events. Each transaction has a unique version number associated with it that dictates its global sequential ordering in the history of the blockchain ledger.
The state is the representation of all transaction outputs up to a specific version. In other words, a state version is the accumulation of all transactions inclusive of that transaction version.
As transactions execute, they may emit events. Events are hints about changes in on-chain data.
INFO
Ensure the fullnode you're communicating with is up to date. The fullnode must reach the version containing your transaction to retrieve relevant data from it. There can be latency from the fullnodes retrieving state from validator fullnodes, which in turn rely upon validator nodes as the source of truth.

The storage service on a node employs two forms of pruning that erase data from nodes:

state
events, transactions, and everything else
While either of these may be disabled, storing the state versions is not particularly sustainable.

Events and transactions pruning can be disabled via setting the enable_ledger_pruner to false in storage_config.rs. This is default behavior in Mainnet. In the near future, Aptos will provide indexers that mitigate the need to directly query from a node.

The REST API offers querying transactions and events in these ways:

Transactions for an account
Transactions by version
Events by event handle
Reading state with the View function
View functions do not modify blockchain state when called from the API. A View function and its input can be used to read potentially complex on-chain state using Move. For example, you can evaluate who has the highest bid in an auction contract. Here are related files:

view_function.rs for an example
related Move code
specification.
The view function operates like the Aptos Simulation API, though with no side effects and a accessible output path. View functions can be called via the /view endpoint. Calls to view functions require the module and function names along with input type parameters and values.

A function does not have to be immutable to be tagged as #[view], but if the function is mutable it will not result in state mutation when called from the API. If you want to tag a mutable function as #[view], consider making it private so that it cannot be maliciously called during runtime.

In order to use the View functions, you need to publish the module through the Aptos CLI.

In the Aptos CLI, a view function request would look like this:

aptos move view --function-id devnet::message::get_message --profile devnet --args address:devnet
{
  "Result": [
    "View functions rock!"
  ]
}

In the TypeScript SDK, a view function request would look like this:

    const payload: Gen.ViewRequest = {
      function: "0x1::coin::balance",
      type_arguments: ["0x1::aptos_coin::AptosCoin"],
      arguments: [alice.address().hex()],
    };

    const balance = await client.view(payload);

    expect(balance[0]).toBe("100000000");

The view function returns a list of values as a vector. By default, the results are returned in JSON format; however, they can be optionally returned in Binary Canonical Serialization (BCS) encoded format.

Exchanging and tracking coins
Aptos has a standard Coin type define in coin.move. Different types of coins can be represented in this type through the use of distinct structs that symbolize the type parameter or use generic for Coin<T>.

Coins are stored within an account under the resource CoinStore<T>. At account creation, each user has the resource CoinStore<0x1::aptos_coin::AptosCoin> or CoinStore<AptosCoin>, for short. Within this resource is the Aptos coin: Coin<AptosCoin>.

Transferring coins between users
Coins can be transferred between users via the coin::transfer function for all coins and aptos_account::transfer for Aptos coins. The advantage of the latter function is that it creates the destination account if it does not exist.

CAUTION
It is important to note that if an account has not registered a CoinStore<T> for a given T, then any transfer of type T to that account will fail.

Current balance for a coin
The current balance for a Coin<T> where T is the Aptos coin is available at the account resources URL: https://{rest_api_server}/accounts/{address}/resource/0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>. The balance is stored within coin::amount. The resource also contains the total number of deposit and withdraw events, and the counter value within deposit_events and withdraw_events, respectively.

{
  "type": "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>",
  "data": {
    "coin": {
      "value": "3927"
    },
    "deposit_events": {
      "counter": "1",
      "guid": {
        "id": {
          "addr": "0xcb2f940705c44ba110cd3b4f6540c96f2634938bd5f2aabd6946abf12ed88457",
          "creation_num": "2"
        }
      }
    },
    "withdraw_events": {
      "counter": "1",
      "guid": {
        "id": {
          "addr": "0xcb2f940705c44ba110cd3b4f6540c96f2634938bd5f2aabd6946abf12ed88457",
          "creation_num": "3"
        }
      }
    }
  }
}

Querying transactions
In Aptos, each transaction is committed as a distinct version to the blockchain. This allows for the convenience of sharing committed transactions by their version number; to do so, query: https://{rest_server_api}/transactions/by_version/{version}

Transactions submitted by an account can also be queried via the following URL where the sequence_number matches the sequence number of the transaction: https://{rest_server_api}/account/{address}/transactions?start={sequence_number}&limit=1

A transfer transaction would appear as follows:

{
  "version": "13629679",
  "gas_used": "4",
  "success": true,
  "vm_status": "Executed successfully",
  "changes": [
    {
      "address": "0xb258b91eee04111039320a85b0c24a2dd433909e14a6b5c32ee722e0fdecfddc",
      "data": {
        "type": "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>",
        "data": {
          "coin": {
            "value": "1000"
          },
          "deposit_events": {
            "counter": "1",
            "guid": {
              "id": {
                "addr": "0x5098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e",
                "creaton_num": "2",
              }
            }
          },
          ...
        }
      },
      "type": "write_resource"
    },
    ...
  ],
  "sender": "0x810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b",
  "sequence_number": "0",
  "max_gas_amount": "2000",
  "gas_unit_price": "1",
  "expiration_timestamp_secs": "1660616127",
  "payload": {
    "function": "0x1::coin::transfer",
    "type_arguments": [
      "0x1::aptos_coin::AptosCoin"
    ],
    "arguments": [
      "0x5098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e",
      "1000"
    ],
    "type": "entry_function_payload"
  },
  "events": [
    {
      "key": "0x0300000000000000810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b",
      "guid": {
        "id": {
          "addr": "0x810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b",
          "creation_num": "3"
          }
        }
      },
      "sequence_number": "0",
      "type": "0x1::coin::WithdrawEvent",
      "data": {
        "amount": "1000"
      }
    },
    {
      "key": "0x02000000000000005098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e",
      guid": {
        "id": {
          "addr": "0x5098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e",
          "creation_num": "2"
          }
        }
      },
      "sequence_number": "0",
      "type": "0x1::coin::DepositEvent",
      "data": {
        "amount": "1000"
      }
    }
  ],
  "timestamp": "1660615531147935",
  "type": "user_transaction"
}


Here is a breakdown of the information in a transaction:

version indicates the globally unique identifier for this transaction, its ordered position in all the committed transactions on the blockchain
sender is the account address of the entity that submitted the transaction
gas_used is the units paid for executing the transaction
success and vm_status indicate whether or not the transaction successfully executed and any reasons why it might not have
changes include the final values for any state resources that have been modified during the execution of the transaction
events contain all the events emitted during the transaction execution
timetstamp is the near real-time timestamp of the transaction's execution
If success is false, then vm_status will contain an error code or message that resulted in the transaction failing to succeed. When success is false, changes will be limited to gas deducted from the account and the sequence number incrementing. There will be no events.

Each event in events is differentiated by a key. The key is derived from the guid in changes. Specifically, the key is a 40-byte hex string where the first eight bytes (or 16 characters) are the little endian representation of the creation_num in the guid of the changes event, and the remaining characters are the account address.

As events do not dictate what emitted them, it is imperative to track the path in changes to determine the source of an event. In particular, each CoinStore<T> has both a WithdrawEvent and a DepositEvent, based upon the type of coin. In order to determine which coin type is used in a transaction, an indexer can compare the guid::creation_num in a changes event combined with the address to the key for events in events.

Using the above example, events[1].guid is equivalent to changes[0].data.data.deposit_events.guid, which is {"addr": "0x5098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e", "creation_num": "2"}.

TIP
The key field will be going away in favor of guid

Querying events
Aptos provides clear and canonical events for all withdraw and deposit of coins. This can be used in coordination with the associated transactions to present to a user the change of their account balance over time, when that happened, and what caused it. With some amount of additional parsing, you can share metadata such as the transaction type and the other parties involved.

Query events by handle URL: https://{rest_api_server}/accounts/{address}/events/0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>/withdraw_events

[
  {
    "version":"13629679",
    "key": "0x0300000000000000cb2f940705c44ba110cd3b4f6540c96f2634938bd5f2aabd6946abf12ed88457",
    "guid": {
      "id": {
        "addr": "0x810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b",
        "creation_num": "3"
        }
      }
    },
    "sequence_number": "0",
    "type": "0x1::coin::WithdrawEvent",
    "data": {
      "amount": "1000"
    }
  }
]

Gather more information from the transaction that generated the event by querying https://{rest_server_api}/transactions/by_version/{version} where {version} is the same value as the {version} in the event query.

TIP
When tracking full movement of coins, normally events are sufficient. 0x1::aptos_coin::AptosCoin, however, requires considering gas_used for each transaction sent from the given account since it represents gas in Aptos. To reduce unnecessary overhead, extracting gas fees due to transactions does not emit an event. All transactions for an account can be retrieved from this API: https://{rest_server_api}/accounts/{address}/transactions

Tracking coin balance changes
Consider the transaction from the earlier section, but now with an arbitrary coin 0x1337::my_coin::MyCoin and some gas parameters changed:

{
  "version": "13629679",
  "gas_used": "20",
  "success": true,
  "vm_status": "Executed successfully",
  "changes": [
    {
      "address": "0xb258b91eee04111039320a85b0c24a2dd433909e14a6b5c32ee722e0fdecfddc",
      "data": {
        "type": "0x1::coin::CoinStore<0x1337::my_coin::MyCoin>",
        "data": {
          "coin": {
            "value": "1000"
          },
          "deposit_events": {
            "counter": "1",
            "guid": {
              "id": {
                "addr": "0x5098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e",
                "creaton_num": "2",
              }
            }
          },
          ...
        }
      },
      "type": "write_resource"
    },
    ...
  ],
  "sender": "0x810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b",
  "sequence_number": "0",
  "max_gas_amount": "2000",
  "gas_unit_price": "110",
  "expiration_timestamp_secs": "1660616127",
  "payload": {
    "function": "0x1::coin::transfer",
    "type_arguments": [
      "0x1337::my_coin::MyCoin"
    ],
    "arguments": [
      "0x5098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e",
      "1000"
    ],
    "type": "entry_function_payload"
  },
  "events": [
    {
      "key": "0x0300000000000000810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b",
      "guid": {
        "id": {
          "addr": "0x810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b",
          "creation_num": "3"
          }
        }
      },
      "sequence_number": "0",
      "type": "0x1::coin::WithdrawEvent",
      "data": {
        "amount": "1000"
      }
    },
    {
      "key": "0x02000000000000005098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e",
      guid": {
        "id": {
          "addr": "0x5098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e",
          "creation_num": "2"
          }
        }
      },
      "sequence_number": "0",
      "type": "0x1::coin::DepositEvent",
      "data": {
        "amount": "1000"
      }
    }
  ],
  "timestamp": "1660615531147935",
  "type": "user_transaction"
}

There are three balance changes in this transaction:

A withdrawal of 1000 of 0x1337::my_coin::MyCoin from the transaction sending account 0x810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b
A deposit of 1000 of 0x1337::my_coin::MyCoin to receiving account 0x5098df8e7969b58ab3bd2d440c6203f64c60a1fd5c08b9d4abe6ae4216246c3e
A gas fee 2200 of 0x1::aptos_coin::AptosCoin from the sending account 0x810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b
To retrieve the withdrawal information:

Scan the changes for 0x1::coin::CoinStore<CoinType>. Note the CoinType is a generic signifying which coin is stored in the store. In this example, the CoinType is 0x1337::my_coin::MyCoin.
Retrieve the guid for withdraw_events. In this example, the guid contains addr 0x810026ca8291dd88b5b30a1d3ca2edd683d33d06c4a7f7c451d96f6d47bc5e8b and creation_num 3.
Scan for events with this guid and extract the event associated with it. In this example, it is the 0x1::coin::WithdrawEvent.
Note the amount field will be the number of CoinType removed from the account in the guid. In this example, it is 1000.
To retrieve the deposit information, it's the same as withdrawal except:

The guid used is under: deposit_events
The amount will be a positive increase on the account's balance.
The event's name will be: 0x1::coin::DepositEvent
To retrieve the gas fee:

The gas_used field must be multiplied times the gas_unit_price. In this example, gas_used=20 and gas_unit_price=110 so the total gas coins withdrawn is 2200.
Gas is always: 0x1::aptos_coin::AptosCoin
To retrieve information about the number of decimals of the coin:

You can retrieve the number of decimals for a coin via its: 0x1::coin::CoinInfo<CoinType>
This will be located at the address of the coin type. In this example, you would need to look up 0x1::coin::CoinInfo<0x1337::my_coin::MyCoin> at address 0x1337.
TIP
If you always use the events in this manner, you won't miss any balance changes for an account. By monitoring the events, you will find all balance changes in the 0x1::coin::CoinStore:

Coin mints
Coin burns
Coin transfers
Staking coins
Withdrawing staked coins
Transfers not derived from coin::transfer
To create some sample data to explore, conduct "Your first transaction".

To learn more about coin creation, make "Your First Coin".

Integrate with Aptos wallets
Decentralized applications often run through a browser extension or mobile application to read onchain data and submit transactions. The Aptos Wallet Adapter allows for a single interface for apps and wallets to integrate together.

Implementing the Aptos Wallet Adapter
For the best user experience, we suggest that dapps offer multiple wallets, to allow users to choose their preferred wallet.

Implementing wallet integration can be difficult for dapps in:

Support and test all edge cases
Implement and maintain different wallet APIs
Provide users with needed functionality the wallet itself doesnt support
Keep track on all the different wallets in our ecosystem
In addition, creating and implementing a wallet is also not an easy task,

Provide a wallet that follows a known standard so it is easy to integrate with
Getting visibility and exposure in the ecosystem among all the other wallets
Dapp projects need to dedicate time and resource to integrate the wallet within their app
When we started building a wallet adapter, we wanted to provide an adapter that can be easy enough for wallets to integrate with and for dapps to use and implement.

For that, we provide an Aptos Wallet Adapter monorepo for wallet and dapps creators to ease development and ensure a smooth process in building projects on the Aptos network. The Aptos Wallet Adapter acts as a service between dapps and wallets and exposes APIs for dapps to interact with the wallets by following our Wallet Standard. This in turns allows dapps to support many wallets with minimal integration efforts, and for wallets to follow a known standard and gain visibility.

Adapter structure
The adapter has three different components, the:

Adapter Core package
Adapter React provider (for dapps)
Adapter Template plugin (for wallets)
This structure offers the following benefits:

Modularity (separation of concerns) - separating the adapter into three components can help having more freedom in design, implementation, deployment and usage.
Wallets create and own their plugin implementation (instead of having all in the same monorepo):
Reduces the packages bundle size used by dapps.
Lets them be self-service and support themselves without too much friction.
Prevents build failures in case of any bugs/bad implementation/wrong config files/etc.
Simplicity - keeps the Provider package very light and small as the major logic is implemented in the core package.
Flexibility - for wallets in creating and implementing custom functions.
Adapter Core package
The Adapter Core package handles the interaction between the dapp and the wallet. It:

Exposes the standard API (and some different functions supported by different wallets)
Holds the current wallet state and the installed wallets
Emits events on different actions and much more
Dapps should not know this package as dapps interact with the provider, which in turn interacts with the core package; some Types are exposed from the core package for the dapp to use.

Wallets should implement their own plugin class that extends the basic plugin class (properties + events) interface that lives in the core package.

TIP
If a wallet supports functions that are not part of the basic plugin interface, a pull request should be made to the core package to include this function so it can support it. You can take a look at the signTransaction on the wallet core package for guidance.

Adapter React provider
The light Adapter React package is for dapps to import and use. The package contains a Provider and a Context to implement and use within your app.

Follow the Wallet Adapter For Dapp Builders guide on how to use the provider package on your dapp.

Adapter Template plugin
Wallets looking to integrate with the adapter should implement their own wallet plugin, to ease the process we provide you with a pre-made class that implements the basic functionality needed (according to the wallet standard).

The Wallet Adapter Plugin Template repo holds a pre-made class, a test file, and some config files to help you build and publish the plugin as an NPM package.

Follow the Wallet Adapter For Wallet Builders on how to use the template to implement and publish your wallet plugin.

Wallet Adapter Concept

Wallet Adapter For Dapp Builders
Imagine you have a great idea for a dapp and you want to start building it. Eventually, you will need to integrate a wallet or multiple wallets so your users can interact with the Aptos blockchain. Implementing wallet integration can be difficult in supporting all edge cases, new features, unsupported functionality. And it can be even harder to support multiple wallets.

In addition, different wallets have different APIs, and not all wallets share the same naming convention. For example, maybe all wallets have a connect method, but not all wallets call that method connect; that can be tricky to support.

Luckily, Aptos built a wallet adapter, created and maintained by the Aptos team, to help you ramp up development and standardize where possible.

The Aptos Wallet Adapter provides:

Easy wallet implementation - no need to implement and support code for multiple wallets.
Support for different wallet APIs.
Support for features not implemented on the wallet level.
Detection for uninstalled wallets (so you can show users that a wallet is not installed).
Auto-connect functionality and remembers the current wallet state.
Listens to wallet events, such as account and network changes.
A well-developed and maintained reference implementation by the Aptos ecosystem team.
Install
Currently, the adapter supports a React provider for you to include in your app.

Install wallet dependencies you want to include in your app. You can find a list of the wallets in the Aptos Wallet Adapter README.

Install the React provider:

npm install @aptos-labs/wallet-adapter-react

Import dependencies
In the App.jsx file:

Import the installed wallets:

import { PetraWallet } from "petra-plugin-wallet-adapter";

Import the AptosWalletAdapterProvider:

import { AptosWalletAdapterProvider } from "@aptos-labs/wallet-adapter-react";

Wrap your app with the Provider, pass it the plugins (wallets) you want to have on your app as an array, and include an autoConnect option (set to false by default):

const wallets = [new PetraWallet()];
<AptosWalletAdapterProvider plugins={wallets} autoConnect={true}>
  <App />
</AptosWalletAdapterProvider>;

Use
On any page you want to use the wallet properties, import useWallet from @aptos-labs/wallet-adapter-react:

import { useWallet } from "@aptos-labs/wallet-adapter-react";

You can then use the exported properties:

const {
  connect,
  account,
  network,
  connected,
  disconnect,
  wallet,
  wallets,
  signAndSubmitTransaction,
  signTransaction,
  signMessage,
} = useWallet();

Finally, use the examples on the package README file to build more functionality into your dapps.

Wallet Adapter For Wallet Builders
To gain from dapps in the Aptos Ecosystem and provide your users the functionality they are looking for in a wallet, your wallet plugin should follow the Aptos Wallet Standard and be built from the Aptos Wallet Adapter.

The wallet-adapter-plugin-template repository gives wallet builders a pre-made class with all required wallet functionality following the Aptos Wallet Standard for easy and fast development.

Configuration
git clone git@github.com:aptos-labs/wallet-adapter-plugin-template.git
Open src/index.ts for editing.
Replace all AptosWindow references with: <Your-Wallet-Name>Window
Replace AptosWalletName with: <Your-Wallet-Name>WalletName
Replace url with your website URL.
Change icon to your wallet icon (pay attention to the required format).
Replace window.aptos with: window.<your-wallet-name>
Make sure the Window Interface has <your-wallet-name> as a key (instead of aptos).
Open __tests/index.test.tsx and change AptosWallet to: <Your-Wallet-Name>Wallet
Run tests with pnpm test - all tests should pass.
At this point, you have a ready wallet class with all required properties and functions to integrate with the Aptos Wallet Adapter.

Publish as a package
The next step is to publish your wallet as an NPM package so dapps can install it as a dependency. Use one of the options below:

Creating and publishing scoped public packages

Creating and publishing unscoped public packages

TIP
If your wallet provides functionality that is not included, you should open a pull request against aptos-wallet-adapter in the core package to have it support this functionality. See the signTransaction on the wallet core package for guidance.

Add your name to the wallets list
Once the package is published, create a pull request against the aptos-wallet-adapter package and add your wallet name to the supported wallet list on the README file as a URL to your NPM package.

Create a Signed Transaction
All transactions executed on the Aptos blockchain must be signed. This requirement is enforced by the chain for security reasons.

Generating the signing message
The first step in signing a transaction is to generate the signing message from the transaction. To generate such a signing message, you can use:

The Aptos node's REST API. The Aptos node will generate the signing message, the transaction signature and will submit the signed transaction to the Aptos blockchain. However, this approach is not secure.
Also see the tutorial Your First Transaction that explains this approach.
However, you may prefer instead that your client application, for example, a hardware security module (HSM), be responsible for generating the signed transaction. In this approach, before submitting transactions, a client must:
Serialize the transactions into bytes, and
Sign the bytes with the account private key. See Accounts for how accounts and private keys work.
This guide will introduce the concepts behind constructing a transaction, generating the appropriate message to sign using the BCS-serialization, and various methods for signing within Aptos.

TIP
We strongly recommend that you use the BCS format for submitting transactions to the Aptos blockchain.

Overview
Creating a transaction that is ready to be executed on the Aptos blockchain requires the following four steps:

Create a raw transaction, RawTransaction, also called unsigned transaction.
Generate the signing message containing the appropriate salt (prefix_bytes), and generate the signature of the raw transaction by using the client's private key.
Create the Authenticator and the signed transaction, and
BCS-serialize the signed transaction (not shown in the diagram in Overview section).
INFO
Code examples in this section are in Typescript.

See the below high-level flow diagram showing how a raw transaction becomes a signed transaction:

Signed Transaction Flow
Unsigned transactions are known as RawTransactions. They contain all the information about how to execute an operation on an account within Aptos. But they lack the appropriate authorization with a signature or Authenticator.

In Aptos blockchain, all the data is encoded as BCS (Binary Canonical Serialization).

Aptos supports many different approaches to signing a transaction but defaults to a single signer using the Ed25519 signature scheme.

The Authenticator produced during the signing of the transaction gives authorization to the Aptos blockchain to execute the transaction on behalf of the account owner.

Key concepts
Raw transaction
A raw transaction consists of the following fields:

sender (Address): Account address of the sender.
sequence_number (uint64): Sequence number of this transaction. This must match the sequence number stored in the sender's account at the time the transaction executes.
payload: Instructions for the Aptos blockchain, including publishing a module, execute a script function or execute a script payload.
max_gas_amount (uint64): Maximum total gas to spend for this transaction. The account must have more than this gas or the transaction will be discarded during validation.
gas_unit_price (uint64): Price to be paid per gas unit. During execution the total_gas_amount, calculated as: total_gas_amount = total_gas_units_consumed * gas_unit_price, must not exceed max_gas_amount or the transaction will abort during the execution. total_gas_units_consumed represents the total units of gas consumed when executing the transaction.
expiration_timestamp_secs (uint64): The blockchain timestamp at which the blockchain would discard this transaction.
chain_id (uint8): The chain ID of the blockchain that this transaction is intended to be run on.
BCS
Binary Canonical Serialization (BCS) is a serialization format applied to the raw (unsigned) transaction. See BCS for a description of the design goals of BCS.

BCS is not a self-describing format. As such, in order to deserialize a message, one must know the message type and layout ahead of time.

An example of how BCS serializes a string is shown below:

// A string is serialized as: byte length + byte representation of the string. The byte length is required for deserialization. Without it, no way the deserializer knows how many bytes to deserialize.
const bytes: Uint8Array = bcs_serialize_string("aptos");
assert(bytes == [5, 0x61, 0x70, 0x74, 0x6f, 0x73]);


Signing message
The bytes of a BCS-serialized raw transaction are referred as a signing message.

In addition, in Aptos, any content that is signed or hashed is salted with a unique prefix to distinguish it from other types of messages. This is done to ensure that the content can only be used in the intended scenarios. The signing message of a RawTransaction is prefixed with prefix_bytes, which is sha3_256("APTOS::RawTransaction"). Therefore:

signing_message = prefix_bytes | bcs_bytes_of_raw_transaction.. | denotes concatenation.

NOTE
The prefixing step is not shown in the diagram in the Overview section.

Batch signing
For batch transactions, create vector of SignedTransactions, and then BCS encode the vector as a whole, like so:

let txn_payload = bcs::to_bytes(&txns.to_vec())?;

For example, see the pub async fn submit_batch_bcs( reference in lib.rs. BCS encode only the array.

By default, you are limited to 10 batched transactions by the max_submit_transaction_batch_size API, which can be overridden if you run your own fullnode by changing the setting: pub const DEFAULT_MAX_SUBMIT_TRANSACTION_BATCH_SIZE: usize = 10;

Signature
A signature is the result of hashing the signing message with the client's private key. By default Aptos uses the Ed25519 scheme to generate the signature of the raw transaction.

By signing a signing message with the private key, clients prove to the Aptos blockchain that they have authorized the transaction be executed.
Aptos blockchain will validate the signature with client account's public key to ensure that the transaction submitted is indeed signed by the client.
Signed transaction
A signed transaction consists of:

A raw transaction, and
An authenticator. The authenticator contains a client's public key and the signature of the raw transaction.
This signed transaction is further BCS-serialized (not shown in the diagram in Overview section), after which the signed transaction is ready for submission to the Aptos REST interface.

Multisignature transactions
The Aptos blockchain supports several signing methods for transactions, including the single signature, the K-of-N multisig, and more.

A K-of-N multisig transaction means that for such a transaction to be executed, at least K out of the N authorized signers have signed the transaction and passed the check conducted by the chain.

Transaction signatures are wrapped in Authenticator. The Aptos blockchain validates the transactions submitted by clients by using the Authenticator data. See a few examples below:

In Typescript, this is how a single signer authenticator looks like:

interface Authenticator {
  public_key: Uint8Array;
  signature: Uint8Array;
}

A multisig authenticator example is shown below:

interface MultiEd25519PublicKey {
  // A list of public keys
  public_keys: Uint8Array[];
  // At least `threshold` signatures must be valid
  threshold: Uint8;
}

interface MultiEd25519Signature {
  // A list of signatures
  signatures: Uint8Array[];
  // 4 bytes, at most 32 signatures are supported.
  // If Nth bit value is `1`, the Nth signature should be provided in `signatures`. Bits are read from left to right
  bitmap: Uint8Array;
}

interface MultisigAuthenticator {
  public_key: MultiEd25519PublicKey;
  signature: MultiEd25519Signature;
}


Detailed steps
Creating a RawTransaction.
Preparing the message to be signed and signing it.
Creating an Authenticator and a SignedTransaction.
Serializing SignedTransaction.
Step 1. Creating a RawTransaction
The below example assumes the transaction has a script function payload.

interface AccountAddress {
  // 32-byte array
  address: Uint8Array;
}

interface ModuleId {
  address: AccountAddress;
  name: string;
}

interface ScriptFunction {
  module: ModuleId;
  function: string;
  ty_args: string[];
  args: Uint8Array[];
}

interface RawTransaction {
  sender: AccountAddress;
  sequence_number: number;
  payload: ScriptFunction;
  max_gas_amount: number;
  gas_unit_price: number;
  expiration_timestamp_secs: number;
  chain_id: number;
}

function createRawTransaction(): RawTransaction {
  const payload: ScriptFunction = {
    module: {
      address: hexToAccountAddress("0x01"),
      name: "AptosCoin",
    },
    function: "transfer",
    ty_args: [],
    args: [
      BCS.serialize(hexToAccountAddress("0x02")), // receipient of the transfer
      BCS.serialize_uint64(2), // amount to transfer
    ],
  };

  return {
    sender: hexToAccountAddress("0x01"),
    sequence_number: 1n,
    max_gas_amount: 2000n,
    gas_unit_price: 1n,
    // Unix timestamp, in seconds + 10 minutes
    expiration_timestamp_secs: Math.floor(Date.now() / 1000) + 600,
    payload: payload,
    chain_id: 3,
  };
}

NOTE
The BCS serialization shown in the code above is not the same as the BCS Serialization operation shown in the Overview section.

Step 2. Creating the signing message and signing it
Generate prefix (prefix_bytes) with SHA3-256 hash bytes of string APTOS::RawTransaction.
Bytes of BCS serialized RawTransaction.
Concat the prefix and BCS bytes.
Signing the bytes with account private key.
import * as Nacl from "tweetnacl";

function hashPrefix(): Buffer {
  let hash = SHA3.sha3_256.create();
  hash.update(`APTOS::RawTransaction`);
  return Buffer.from(hash.arrayBuffer());
}

function bcsSerializeRawTransaction(txn: RawTransaction): Buffer {
  ...
}

// This will serialize a raw transaction into bytes
function serializeRawTransaction(txn: RawTransaction): Buffer {
  // Generate a hash prefix
  const prefix = hashPrefix();

  // Serialize txn with BCS
  const bcsSerializedTxn = bcsSerializeRawTransaction(txn);

  return Buffer.concat([prefix, bcsSerializedTxn]);
}

const rawTxn = createRawTransaction();
const signature = Nacl.sign(hashRawTransaction(rawTxn), ACCOUNT_PRIVATE_KEY);

Step 3. Creating an Authenticator and a SignedTransaction
interface Authenticator {
  public_key: Uint8Array;
  signature: Uint8Array;
}

interface SignedTransaction {
  raw_txn: RawTransaction;
  authenticator: Authenticator;
}

const authenticator = {
  public_key: PUBLIC_KEY,
  signature: signature,
};

const signedTransaction: SignedTransaction = {
  raw_txn: rawTxn,
  authenticator: authenticator,
};

Step 4. Serializing SignedTransaction
NOTE
This step is not shown in the flow diagram in the Overview section.

Serializing SignedTransaction into bytes with BCS.

const signedTransactionPayload = bcsSerializeSignedTransaction(signedTransaction);

Submitting the signed transaction
Finally, submitting the transaction with the required header "Content-Type".

To submit a signed transaction in the BCS format, the client must pass in a specific header, as shown in the below example:

curl -X POST -H "Content-Type: application/x.aptos.signed_transaction+bcs" --data-binary "@path/to/file

Integrate with Aptos Names Service
The Aptos Name Service provides a React UI package that offers developers a customizable button and modal to enable users to search for and mint Aptos names directly from their website.

Prerequisites
React project
Supporting dependencies installed in the root directory of your React project with npm or yarn:
npm install @emotion/styled @emotion/react
yarn add @emotion/styled @emotion/react react-copy-to-clipboard
Use Aptos Names Service Connector
Open a terminal session and navigate to the root directory of your React project.

Install the aptos-names-connector package using npm or yarn:

npm install "@aptos-labs/aptos-names-connector"
yarn add "@aptos-labs/aptos-names-connector"
Once you have installed the package, you can import the AptosNamesConnector component and use it in your React application (by default in ./src/App.js):

import { AptosNamesConnector } from "@aptos-labs/aptos-names-connector";

function MyComponent() {
  const handleSignTransaction = async () => {
    // Handle signing of transaction
  };

  return (
    <AptosNamesConnector
      onSignTransaction={handleSignTransaction}
      isWalletConnected={true}
      network="mainnet"
      buttonLabel="Claim"
    />
  );
}

To see your changes, start a development server using npm or yarn. The following commands will open the React application in your default web browser (typically to localhost:3000):

npm start
yarn start
Configure AptosNamesConnector properties
The AptosNamesConnector component accepts the following props:

onSignTransaction: A required callback function that is called when the user clicks the "Mint" button in the modal. This function should handle the signing of the transaction.
isWalletConnected: A boolean value that indicates whether the user's wallet is connected.
network: A string value that specifies whether the component should connect to the mainnet or testnet.
buttonLabel: A string value that specifies the text to display on the button.
Customize button label and appearance
The button label can be customized by passing a string value to the buttonLabel prop. The appearance of the button in the AptosNamesConnector component can be customized to fit in your website. The button has the CSS class name of ans_connector_button:

.ans-connector-button {
  background-color: #000000;
  border: none;
  border-radius: 4px;
  color: #ffffff;
  cursor: pointer;
  font-size: 16px;
  font-weight: bold;
  padding: 12px 16px;
}

To use ans_connector_button in your React application, add import "@aptos-labs/aptos-names-connector/dist/index.css"; to the top of your App.js file and reference it with <button className="ans_connector_button"></button>

Supported networks
The AptosNamesConnector component supports both mainnet and testnet. To connect to the mainnet, set the network prop to "mainnet". To connect to the testnet, set the network prop to "testnet".

Example
The following example shows how to use the AptosNamesConnector component in a React application:

Add a ‘claim name’ button to any page in your application. This allows your users to directly create an Aptos name, giving them a human-readable .apt name for their Aptos wallet address. You can customize the look of the button to suit your application. Here is an example on the profile page of an NFT marketplace.
Claim name

When the button is clicked, the Aptos Names modal will show up, and the user can search for a name and mint it directly in your application.
Show Aptos Name Service modal

Once the user has minted their name, you can replace their Aptos wallet address by querying from Aptos fullnodes. Now your users have a human-readable .apt name.
Claim another name

Handle Errors in Aptos
This page catalogs common errors encountered in the Aptos blockchain and explains how to resolve them wherever possible. As with all software, the code itself is the source of truth for error handling and will always contain entries not found here. Instead, this matrix aims to help you address those errors most typically found, misunderstood, or both.

For the sources of these errors, see:

vm_status.rs
error.move
account.move
coin.move
token.move
token_transfers.move
Help us update this list by sending pull requests containing the errors you encounter. If you don't know how to resolve the error, as described int the Action column, simply leave it blank.

Move Virtual Machine (VM)
Error	Meaning	Possible Resolution
LOOKUP_FAILED	A function that is being called isn't present on the network being used	Check that your dependencies onchain have the same version
UNKNOWN_VALIDATION_STATUS	We don't want the default value to be valid.	N/A
INVALID_SIGNATURE	The transaction has a bad signature.	Submit a new transaction with a new signature
INVALID_AUTH_KEY	Bad account authentication key.	Submit a new transaction with a new signature, check that the account matches the authentication key and hasn't been rotated
SEQUENCE_NUMBER_TOO_OLD	Sequence number is too old.	Submit a new transaction with a newer sequence number from the account
SEQUENCE_NUMBER_TOO_NEW	Sequence number is too new.	Submit a new transaction with a new signature
INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE	Insufficient balance to pay minimum transaction fee.	Fund the account with more APT to pay for the gas fee
TRANSACTION_EXPIRED	The transaction has expired.	Submit a new transaction with an expiration time further in the future
SENDING_ACCOUNT_DOES_NOT_EXIST	The sending account does not exist.	Create the account prior to sending the transaction again
REJECTED_WRITE_SET	This write set transaction was rejected because it did not meet the requirements for one.	N/A
INVALID_WRITE_SET	This write set transaction cannot be applied to the current state.	N/A
EXCEEDED_MAX_TRANSACTION_SIZE	Length of program field in raw transaction exceeded max length.	The transaction is too large for a single transaction; if this is a package publish, try to break it into multiple packages
UNKNOWN_SCRIPT	This script is not in our allowlist of scripts.	N/A
UNKNOWN_MODULE	Transaction is trying to publish a new module.	N/A
MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND	Max gas units submitted with transaction exceeds max gas units bound in VM.	Decrease the max gas amount in the transaction below the maximum value in the gas schedule
MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS	Max gas units submitted with transaction not enough to cover the intrinsic cost of the transaction.	Increase the max gas amount above the minimum value in the gas schedule
GAS_UNIT_PRICE_BELOW_MIN_BOUND	Gas unit price submitted with transaction is below minimum gas price set in the VM.	Increase the gas unit price below the minimum gas unit price in the gas schedule
GAS_UNIT_PRICE_ABOVE_MAX_BOUND	Gas unit price submitted with the transaction is above the maximum gas price set in the VM.	Decrease the gas unit price below the maximum gas unit price in the gas schedule
INVALID_GAS_SPECIFIER	Gas specifier submitted is either malformed (not a valid identifier), or does not refer to an accepted gas specifier.	N/A
SENDING_ACCOUNT_FROZEN	The sending account is frozen.	N/A
UNABLE_TO_DESERIALIZE_ACCOUNT	Unable to deserialize the account blob.	N/A
CURRENCY_INFO_DOES_NOT_EXIST	The currency info was unable to be found.	N/A
INVALID_MODULE_PUBLISHER	The account sender doesn't have permissions to publish modules.	N/A
NO_ACCOUNT_ROLE	The sending account has no role.	N/A
BAD_CHAIN_ID	The transaction's chain_id does not match the one published on-chain.	Verify that your chain ID matches the chain ID for your network
SEQUENCE_NUMBER_TOO_BIG	The sequence number is too large and would overflow if the transaction were executed.	N/A
BAD_TRANSACTION_FEE_CURRENCY	The gas currency is not registered as a TransactionFee currency.	N/A
FEATURE_UNDER_GATING	The feature requested is intended for a future Aptos version instead of the current one.	N/A
SECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH	The number of secondary signer addresses is different from the number of secondary public keys provided.	Verify the multi-agent or multi-ed25519 secondary signer addresses match the secondary public keys
SIGNERS_CONTAIN_DUPLICATES	There are duplicates among signers, including the sender and all the secondary signers.	Remove any duplicate signers
SEQUENCE_NONCE_INVALID	The sequence nonce in the transaction is invalid (too new, too old, or already used).	N/A
CHAIN_ACCOUNT_INFO_DOES_NOT_EXIST	There was an error when accessing chain-specific account information.	N/A
MODULE_ADDRESS_DOES_NOT_MATCH_SENDER	the module publisher is not the account that will eventually hold the module.	Confirm the module address in the move contract matches the sender of the transaction
ZERO_SIZED_STRUCT	Reported when a struct has zero fields.	N/A
DUPLICATE_MODULE_NAME	The sender is trying to publish two modules with the same name in one transaction.	Confirm every module has a unique name
BACKWARD_INCOMPATIBLE_MODULE_UPDATE	The sender is trying to publish a module that breaks the compatibility checks.	Confirm your new modules being published don't break backwards compatibility
CYCLIC_MODULE_DEPENDENCY	The updated module introduces a cyclic dependency (i.e., A uses B and B also uses A).	Check for loops in your module dependencies in the modules being published
INVALID_FRIEND_DECL_WITH_SELF	Cannot mark the module itself as a friend.	Confirm no module has itself marked as a friend in the modules being published
INVALID_FRIEND_DECL_WITH_MODULES_OUTSIDE_ACCOUNT_ADDRESS	Cannot declare modules outside of account address as friends.	Confirm all friends are in the same account address in the modules being published
INVALID_FRIEND_DECL_WITH_MODULES_IN_DEPENDENCIES	Cannot declare modules that this module depends on as friends.	Check friend declarations of the modules being published
CYCLIC_MODULE_FRIENDSHIP	The updated module introduces a cyclic friendship (i.e., A friends B and B also friends A).	Check friend declarations of the modules being published
INVALID_PHANTOM_TYPE_PARAM_POSITION	A phantom type parameter was used in a non-phantom position.	Confirm phantom types are used only with generics
LOOP_MAX_DEPTH_REACHED	Loops are too deeply nested.	Check for many nested loops
TYPE_RESOLUTION_FAILURE	Failed to resolve type due to linking being broken after verification.	N/A
RESOURCE_DOES_NOT_EXIST	We tried to access a resource that does not exist under the account.	Check the contract and possibly change it to handle resources that don't exist
RESOURCE_ALREADY_EXISTS	We tried to create a resource under an account where that resource already exists.	Check the contract and possibly change it to handle resources that already exist
UNKNOWN_STATUS	A reserved status to represent an unknown vm status. This is std::u64::MAX, but we can't pattern match on that, so put the hardcoded value in.	N/A
LINKER_ERROR	This may be due to the function has not been published on chain or by trying to call an invalid function as the result of either an incorrect account address, module name, or function name. This might not happen locally if the sources are available locally but have yet to be published on-chain.	There are many reasons, but you should check your account addresses, module names, and function names to determine that they're correct and published
Move Standard Library (stdlib)
Error	Meaning
INVALID_ARGUMENT	Caller specified an invalid argument (http: 400).
OUT_OF_RANGE	An input or result of a computation is out of range (http: 400).
INVALID_STATE	The system is not in a state where the operation can be performed (http: 400).
UNAUTHENTICATED	Request not authenticated due to missing, invalid, or expired auth token (http: 401).
PERMISSION_DENIED	The client does not have sufficient permission (http: 403).
NOT_FOUND	A specified resource is not found (http: 404).
ABORTED	Concurrency conflict, such as read-modify-write conflict (http: 409).
ALREADY_EXISTS	The resource that a client tried to create already exists (http: 409).
RESOURCE_EXHAUSTED	Out of gas or other forms of quota (http: 429).
CANCELLED	Request cancelled by the client (http: 499).
INTERNAL	Internal error (http: 500).
NOT_IMPLEMENTED	Feature not implemented (http: 501).
UNAVAILABLE	The service is currently unavailable. Indicates that a retry could solve the issue (http: 503).
Aptos accounts
Error	Meaning	Possible Resolution
EACCOUNT_ALREADY_EXISTS	Account already exists.	N/A
EACCOUNT_DOES_NOT_EXIST	Account does not exist.	Create the account first
ESEQUENCE_NUMBER_TOO_BIG	Sequence number exceeds the maximum value for a u64.	Provide a smaller sequence number
EMALFORMED_AUTHENTICATION_KEY	The provided authentication key has an invalid length.	Check your authentication key; it should be a 32-byte vector
ECANNOT_RESERVED_ADDRESS	Cannot create account because address is reserved.	N/A
EOUT_OF_GAS	Transaction exceeded its allocated max gas.	Increase the max gas amount
EWRONG_CURRENT_PUBLIC_KEY	Specified current public key is not correct.	Confirm the public key matches the account
EINVALID_PROOF_OF_KNOWLEDGE	Specified proof of knowledge required to prove ownership of a public key is invalid.	Check your proof of knowledge in key rotation to ensure it has proper signatures
ENO_CAPABILITY	The caller does not have a digital-signature-based capability to call this function.	Confirm you have the capability for the called functions
EINVALID_ACCEPT_ROTATION_CAPABILITY	The caller does not have a valid rotation capability offer from the other account.	Confirm the account being rotated is correct
ENO_VALID_FRAMEWORK_RESERVED_ADDRESS	Address to create is not a valid reserved address for Aptos framework.	N/A
EINVALID_SCHEME	Specified scheme required to proceed with the smart contract operation - can only be ED25519_SCHEME(0) OR MULTI_ED25519_SCHEME(1).	Confirm the transaction was signed correctly when creating the account
EINVALID_ORIGINATING_ADDRESS	Abort the transaction if the expected originating address is different from the originating address on-chain.	Confirm you are rotating the correct account's key
ENO_SUCH_SIGNER_CAPABILITY	The signer capability doesn't exist at the given address.	Confirm the address is correct
Aptos coins
Error	Meaning	Possible Resolution
ECOIN_INFO_ADDRESS_MISMATCH	Address of account which is used to initialize a coin CoinType doesn't match the deployer of module.	Create the coin using a CoinType in the same account creating the coin.
ECOIN_INFO_ALREADY_PUBLISHED	CoinType is already initialized as a coin.	N/A
ECOIN_INFO_NOT_PUBLISHED	CoinType hasn't been initialized as a coin.	Create the coin with CoinType first before using it
ECOIN_STORE_ALREADY_PUBLISHED	Account already has CoinStore registered for CoinType.	N/A
ECOIN_STORE_NOT_PUBLISHED	Account hasn't registered CoinStore for CoinType.	Register the account for the CoinType
EINSUFFICIENT_BALANCE	Not enough coins to complete transaction.	Transfer less coins, or acquire more coins prior to the transfer
EDESTRUCTION_OF_NONZERO_TOKEN	Cannot destroy non-zero coins.	N/A
EZERO_COIN_AMOUNT	Coin amount cannot be zero.	Don't burn coins or conduct other actions with zero coins
EFROZEN	CoinStore is frozen. Coins cannot be deposited or withdrawn.	Account is frozen for this token; talk to the coin owner
ECOIN_SUPPLY_UPGRADE_NOT_SUPPORTED	Cannot upgrade the total supply of coins to different implementation.	N/A
ECOIN_NAME_TOO_LONG	Name of the coin is too long.	Coin name must be less than or equal to 32 characters
ECOIN_SYMBOL_TOO_LONG	Symbol of the coin is too long.	Coin symbol must be less than or equal to 10 characters
Aptos tokens
Error	Meaning
EALREADY_HAS_BALANCE	The token has balance and cannot be initialized.
ECOLLECTIONS_NOT_PUBLISHED	There isn't any collection under this account.
ECOLLECTION_NOT_PUBLISHED	Cannot find collection in creator's account.
ECOLLECTION_ALREADY_EXISTS	The collection already exists.
ECREATE_WOULD_EXCEED_COLLECTION_MAXIMUM	Exceeds the collection's maximal number of token_data.
EINSUFFICIENT_BALANCE	Insufficient token balance.
EINVALID_TOKEN_MERGE	Cannot merge the two tokens with different token IDs.
EMINT_WOULD_EXCEED_TOKEN_MAXIMUM	Exceed the token data maximal allowed.
ENO_BURN_CAPABILITY	No burn capability.
ETOKEN_DATA_ALREADY_EXISTS	TokenData already exists.
ETOKEN_DATA_NOT_PUBLISHED	TokenData not published.
ETOKEN_STORE_NOT_PUBLISHED	TokenStore doesn't exist.
ETOKEN_SPLIT_AMOUNT_LARGER_THAN_TOKEN_AMOUNT	Cannot split token to an amount larger than its amount.
EFIELD_NOT_MUTABLE	The field is not mutable.
ENO_MUTATE_CAPABILITY	Not authorized to mutate.
ENO_TOKEN_IN_TOKEN_STORE	Token not in the token store.
EUSER_NOT_OPT_IN_DIRECT_TRANSFER	User didn't opt-in direct transfer.
EWITHDRAW_ZERO	Cannot withdraw 0 token.
ENFT_NOT_SPLITABLE	Cannot split a token that only has 1 amount.
ENO_MINT_CAPABILITY	No mint capability
ECOLLECTION_NAME_TOO_LONG	The collection name is too long.
ENFT_NAME_TOO_LONG	The NFT name is too long.
EURI_TOO_LONG	The URI is too long.
ENO_DEPOSIT_TOKEN_WITH_ZERO_AMOUNT	Cannot deposit a token with 0 amount.
ENO_BURN_TOKEN_WITH_ZERO_AMOUNT	Cannot burn 0 token.
EWITHDRAW_PROOF_EXPIRES	Withdraw proof expires.
EOWNER_CANNOT_BURN_TOKEN	Token is not burnable by owner.
ECREATOR_CANNOT_BURN_TOKEN	Token is not burnable by creator.
ECANNOT_UPDATE_RESERVED_PROPERTY	Reserved fields for token contract. Cannot be updated by user.
EURI_TOO_SHORT	URI too short.
ETOKEN_OFFER_NOT_EXIST	Token offer doesn't exist.

Aptos CLI
The aptos tool is a command line interface (CLI) for developing on the Aptos blockchain, debugging, and for node operations. Please refer to the following documentation for more information:

Install Aptos CLI
Use Aptos CLI

Install CLI by script
The aptos tool is a command line interface (CLI) for developing on the Aptos blockchain, debugging Move contracts, and conducting node operations. This document describes how to install the aptos CLI tool using the automated install script.

Prerequisites
First, ensure you have Python 3.6+ installed:

$ python3 --version
Python 3.9.13

If it is not installed, you can find installation instructions on python.org.

Install
Follow these instructions to install the Aptos CLI on various operating systems. Regardless of the operating system, you will always be directed to the latest release of the Aptos CLI.

macOS / Linux / Windows Subsystem for Linux (WSL)
Windows (NT)
Update
To trigger an update to the Aptos CLI, run aptos update and see output indicating success:

{
  "Result": "CLI already up to date (v1.0.4)"
}

Alternatively, you may update your CLI by running the python3 install_cli.py installation script again and receiving output resembling:

Latest CLI release: 1.0.4
Currently installed CLI: 1.0.4

The latest version (1.0.4) is already installed.

Download Aptos CLI Binaries
The aptos tool is a command line interface (CLI) for developing on the Aptos blockchain, debugging Move contracts, and conducting node operations. This document describes how to install the aptos CLI tool using precompiled binaries that reduce variables in setting up your environment. Also see:

Installing the Aptos CLI for alternatives to using the precompiled binaries.
Installing the Move Prover for an optional tool to validate your Move code.
Using Aptos CLI for detailed instructions on employing the Aptos CLI.
Binary releases are recommended for most users, otherwise see Building Aptos From Source

macOS
MacOS
We do not release binaries for MacOS, you must use brew.

Linux
Linux
TIP
These instructions have been tested on Ubuntu 20.04.

Go to the Aptos CLI release page.

Click the Assets expandable menu for the latest release.

You will see the zip files with the filename of the format: aptos-cli-<version>-<platform>. These are the platform-specific pre-compiled binaries of the CLI. Download the zip file for your platform, dismissing any warnings.

Unzip the downloaded file. This will extract the aptos CLI binary file into your default downloads folder.

Move this extracted aptos binary file into your preferred local folder.

TIP
Upgrading? Remember to look in the default download folder When you update the CLI binary with the latest version, note that the newer version binary will be downloaded to your default Downloads folder. Remember to move this newer version binary from the Downloads folder to ~/bin/aptos folder (overwriting the older version).

Make this ~/bin/aptos an executable by running this command:

chmod +x ~/bin/aptos.
Type ~/bin/aptos help to read help instructions.

Add ~/bin to your path in your .bashrc or .zshrc file for future use.

Windows 10, 11 and Windows Server 2022+
Windows 10, 11 and Windows Server 2022+
TIP
These instructions have been tested on Windows 11 and Windows Server 2022. Windows support is new and some features may be not complete. Open GitHub issues for bugs.

Go to the Aptos CLI release page.
Click the Assets expandable menu for the latest release.
You will see the zip files with the filename of the format: aptos-cli-<version>-<platform>. These are the platform-specific pre-compiled binaries of the CLI. Download the zip file for your platform, dismissing any warnings.
Unzip the downloaded file. This will extract the aptos CLI binary file into your default downloads folder. For example, on Windows it is the \Users\user\Downloads folder.
Move this extracted aptos binary file into your preferred local folder.
UPGRADING? REMEMBER TO LOOK IN THE DEFAULT DOWNLOAD FOLDER
When you update the CLI binary with the latest version, note that the newer version binary will be downloaded to your default Downloads folder. Remember to move this newer version binary from the Downloads folder to your preferred location.

Open a powershell terminal via the windows start menu
In the powershell terminal, you can get help instructions by running the command with help. For example .\Downloads\aptos-cli-0.3.5-Windows-x86_64\aptos.exe help to read help instructions.

Install the Aptos CLI with Brew
Recommended on macOS, brew is a package manager that allows for installing and updating packages in a single command.

NOT SUPPORTED ON WINDOWS
Brew is not supported fully on Windows

Installation
Ensure you have brew installed https://brew.sh/
Open a terminal and enter the following commands
    brew update        # Gets the latest updates for packages
    brew install aptos # Installs the Aptos CLI

You can now get help instructions by running aptos help. You may have to open a new terminal window.
   aptos help

Upgrading the CLI
Upgrading the CLI with brew is very simple, simply run

  brew update        # Gets the latest updates for packages
  brew upgrade aptos # Upgrades the Aptos CLI

Additional details
Aptos CLI homebrew Readme

Use the Aptos CLI
The aptos tool is a command line interface (CLI) for developing on the Aptos blockchain, debugging, and for node operations. This document describes how to use the aptos CLI tool. To download or build the CLI, follow Install Aptos CLI.

For example on how to use specific commands, see the following documents:

Configuration and Initialization
Account
Key
Node
Move
Genesis
Command line help
Command line help is available. Type aptos help or aptos --help to see the available command options. See below the usage output from aptos --help:

USAGE:
    aptos <SUBCOMMAND>

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    account       Tool for interacting with accounts
    config        Tool for interacting with configuration of the Aptos CLI tool
    genesis       Tool for setting up an Aptos chain Genesis transaction
    governance    Tool for on-chain governance
    help          Print this message or the help of the given subcommand(s)
    info          Show build information about the CLI
    init          Tool to initialize current directory for the aptos tool
    key           Tool for generating, inspecting, and interacting with keys
    move          Tool for Move related operations
    multisig      Tool for interacting with multisig accounts
    node          Tool for operations related to nodes
    stake         Tool for manipulating stake and stake pools
    update        Update the CLI itself

Command-specific help
Command-specific help is also available. For example, see below the usage output from aptos move --help:


USAGE:
    aptos move <SUBCOMMAND>

OPTIONS:
    -h, --help       Print help information
    -V, --version    Print version information

SUBCOMMANDS:
    build-publish-payload
            Build a publication transaction payload and store it in a JSON output file
    clean
            Cleans derived artifacts of a package
    compile
            Compiles a package and returns the associated ModuleIds
    compile-script
            Compiles a Move script into bytecode
    coverage
            Computes coverage for a package
    create-resource-account-and-publish-package
            Publishes the modules in a Move package to the Aptos blockchain under a resource account
    disassemble
            Disassemble the Move bytecode pointed to
    document
            Documents a Move package
    download
            Downloads a package and stores it in a directory named after the package
    help
            Print this message or the help of the given subcommand(s)
    init
            Creates a new Move package at the given location
    list
            Lists information about packages and modules on-chain for an account
    prove
            Proves a Move package
    publish
            Publishes the modules in a Move package to the Aptos blockchain
    run
            Run a Move function
    run-script
            Run a Move script
    test
            Runs Move unit tests for a package
    verify-package
            Downloads a package and verifies the bytecode
    view
            Run a view function

Sub-command help
Help for sub-commands is also available. For example, see below the usage output from aptos move compile --help:


Usage: aptos move compile [OPTIONS]

Options:
      --save-metadata
          Save the package metadata in the package's build directory
          
          If set, package metadata should be generated and stored in the package's build directory. This metadata can be used to construct a transaction to publish a package.

      --included-artifacts <INCLUDED_ARTIFACTS>
          Artifacts to be generated when building the package
          
          Which artifacts to include in the package. This can be one of `none`, `sparse`, and `all`. `none` is the most compact form and does not allow to reconstruct a source package from chain; `sparse` is the minimal set of artifacts needed to reconstruct a source package; `all` includes all available artifacts. The choice of included artifacts heavily influences the size and therefore gas cost of publishing: `none` is the size of bytecode alone; `sparse` is roughly 2 times as much; and `all` 3-4 as much.
          
          [default: sparse]
          [possible values: none, sparse, all]

      --dev
          Enables dev mode, which uses all dev-addresses and dev-dependencies
          
          Dev mode allows for changing dependencies and addresses to the preset [dev-addresses] and [dev-dependencies] fields.  This works both inside and out of tests for using preset values.
          
          Currently, it also additionally pulls in all test compilation artifacts

      --package-dir <PACKAGE_DIR>
          Path to a move package (the folder with a Move.toml file)

      --output-dir <OUTPUT_DIR>
          Path to save the compiled move package
          
          Defaults to `<package_dir>/build`

      --named-addresses <NAMED_ADDRESSES>
          Named addresses for the move binary
          
          Example: alice=0x1234, bob=0x5678
          
          Note: This will fail if there are duplicates in the Move.toml file remove those first.
          
          [default: ]

      --skip-fetch-latest-git-deps
          Skip pulling the latest git dependencies
          
          If you don't have a network connection, the compiler may fail due to no ability to pull git dependencies.  This will allow overriding this for local development.

      --bytecode-version <BYTECODE_VERSION>
          Specify the version of the bytecode the compiler is going to emit

      --compiler-version <COMPILER_VERSION>
          Specify the version of the compiler
          
          [possible values: v1, v2]

      --skip-attribute-checks
          Do not complain about unknown attributes in Move code

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version


CLI information
Run the aptos info command to get the CLI information for debugging purposes. See an example output of the aptos info command:

{
  "Result": {
    "build_branch": "",
    "build_cargo_version": "cargo 1.71.2 (1a737af0c 2023-08-07)",
    "build_clean_checkout": "true",
    "build_commit_hash": "",
    "build_is_release_build": "true",
    "build_os": "macos-aarch64",
    "build_pkg_version": "2.1.0",
    "build_profile_name": "cli",
    "build_rust_channel": "",
    "build_rust_version": "rustc 1.71.1 (eb26296b5 2023-08-03) (built from a source tarball)",
    "build_tag": "",
    "build_time": "2023-08-24 21:13:40 +00:00",
    "build_using_tokio_unstable": "true"
  }
}

Configuration
Configuration examples
Configuration for the CLI works like this:

In the current working directory for local runs
Your configurations are in a local YAML configuration file .aptos/config.yaml, i.e., located in the current working directory where you run the CLI. In this case you must run your CLI commands from this current working directory for this configuration to be used.
You can verify that the CLI is set to use this local configuration YAML file by running the command:
aptos config show-global-config

You should see the below output:

{
  "Result": {
    "config_type": "Workspace"
  }
}

The Workspace value for the config_type indicates that the .aptos/config.yaml file is used for the CLI configuration.

In the home directory for the global runs
Your configurations are in a global YAML configuration file ~/.aptos/global_config.yaml, i.e., located in your home directory.
Set the CLI to use this global configuration YAML file by running this command:
aptos config set-global-config --config-type global

You will see the below output:

{
  "Result": {
    "config_type": "Global"
  }
}

You can also show the global configuration with the show-global-config command.

$ aptos config show-global-config
{
  "Result": {
    "config_type": "Global"
  }
}

DEFAULT CONFIGURATION
If you did not set any global configuration, then the ./.aptos/config.yaml in the current working directory is used for configuration.

Setting up shell completion
You can set up shell completions with the generate-shell-completions command. You can lookup configuration for your specific shell. The supported shells are [bash, zsh, fish, powershell, elvish]. An example is below for oh my zsh.

aptos config generate-shell-completions --shell zsh --output-file ~/.oh-my-zsh/completions/_aptos

Initialize local configuration and create an account
A local folder named .aptos/ will be created with a configuration config.yaml which can be used to store configuration between CLI runs. This is local to your run, so you will need to continue running CLI from this folder, or reinitialize in another folder.

Step 1: Run Aptos init
The aptos init command will initialize the configuration with the private key you provided. Note: If you would like to initialize a new profile from ledger, please refer to the Ledger documentation.

$ aptos init
Configuring for profile default
Enter your rest endpoint [Current: None | No input: https://fullnode.devnet.aptoslabs.com]

No rest url given, using https://fullnode.devnet.aptoslabs.com...
Enter your faucet endpoint [Current: None | No input: https://faucet.devnet.aptoslabs.com]

No faucet url given, using https://faucet.devnet.aptoslabs.com...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]

No key given, generating key...
Account 00f1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696 doesn't exist, creating it and funding it with 10000 coins
Aptos is now set up for account 00f1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696!  Run `aptos help` for more information about commands

{
  "Result": "Success"
}


Step 2: Changing the configuration
To change the configuration, you can either run the command aptos init or you can manually edit the .aptos/config.yaml that is in your current working directory.

Creating other profiles
You can also create other profiles for different endpoints and different keys. These can be made by adding the --profile argument, and can be used in most other commands to replace command line arguments.

$ aptos init --profile superuser
Configuring for profile superuser
Enter your rest endpoint [Current: None | No input: https://fullnode.devnet.aptoslabs.com]

No rest url given, using https://fullnode.devnet.aptoslabs.com...
Enter your faucet endpoint [Current: None | No input: https://faucet.devnet.aptoslabs.com]

No faucet url given, using https://faucet.devnet.aptoslabs.com...
Enter your private key as a hex literal (0x...) [Current: None | No input: Generate new key (or keep one if present)]

No key given, generating key...
Account 18B61497FD290B02BB0751F44381CADA1657C2B3AA6194A00D9BC9A85FAD3B04 doesn't exist, creating it and funding it with 10000 coins
Aptos is now set up for account 18B61497FD290B02BB0751F44381CADA1657C2B3AA6194A00D9BC9A85FAD3B04!  Run `aptos help` for more information about commands
{
  "Result": "Success"
}

Account
Account examples
Fund an account with the faucet
You can fund an account with the faucet via the CLI by using either an account address or with default (which defaults to the account address created with aptos init).

For example, to fund the account 00f1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696 that was created above with the aptos init command:

$ aptos account fund-with-faucet --account 00f1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696
{
  "Result": "Added 10000 coins to account 00f1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696"
}


$ aptos account fund-with-faucet --account default
{
  "Result": "Added 10000 coins to account 00f1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696"
}


View an account's balance and transfer events
You can view the balance and transfer events (deposits and withdrawals) either by explicitly specifying the account address, as below:

$ aptos account list --query balance --account 00f1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696


or by specifying the default as below:

$ aptos account list --query balance --account default

Both the above commands will generate the following information on your terminal:

{
  "Result": [
    {
      "coin": {
        "value": "110000"
      },
      "deposit_events": {
        "counter": "3",
        "guid": {
          "id": {
            "addr": "0xf1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696",
            "creation_num": "2"
          }
        }
      },
      "frozen": false,
      "withdraw_events": {
        "counter": "0",
        "guid": {
          "id": {
            "addr": "0xf1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696",
            "creation_num": "3"
          }
        }
      }
    }
  ]
}

Listing resources in an account
You can list the resources in an account from the command line. For example, see below for how to list the resources in the account you just created above:

$ aptos account list --query resources --account default

or

$ aptos account list --query resources --account 0xf1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696


Both the above commands will generate the following resource list information on your terminal:

{
  "Result": [
    {
      "0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>": {
        "coin": {
          "value": "110000"
        },
        "deposit_events": {
          "counter": "3",
          "guid": {
            "id": {
              "addr": "0xf1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696",
              "creation_num": "2"
            }
          }
        },
        "frozen": false,
        "withdraw_events": {
          "counter": "0",
          "guid": {
            "id": {
              "addr": "0xf1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696",
              "creation_num": "3"
            }
          }
        }
      }
    },
    {
      "0x1::account::Account": {
        "authentication_key": "0x00f1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696",
        "coin_register_events": {
          "counter": "1",
          "guid": {
            "id": {
              "addr": "0xf1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696",
              "creation_num": "0"
            }
          }
        },
        "guid_creation_num": "4",
        "key_rotation_events": {
          "counter": "0",
          "guid": {
            "id": {
              "addr": "0xf1f20ddd0b0dd2291b6e42c97274668c479bca70f07c6b6a80b99720779696",
              "creation_num": "1"
            }
          }
        },
        "rotation_capability_offer": {
          "for": {
            "vec": []
          }
        },
        "sequence_number": "0",
        "signer_capability_offer": {
          "for": {
            "vec": []
          }
        }
      }
    }
  ]
}

List the default profile
You can also list the default profile from configuration with no account specified.

TIP
Account addresses may differ from example to example in this section.

$ aptos account list
{
  "Result": [
    {
      "coin": {
        "value": "10000"
      },
      "deposit_events": {
        "counter": "1",
        "guid": {
          "id": {
            "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
            "creation_num": "1"
          }
        }
      },
      "withdraw_events": {
        "counter": "0",
        "guid": {
          "id": {
            "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
            "creation_num": "2"
          }
        }
      }
    },
    {
      "register_events": {
        "counter": "1",
        "guid": {
          "id": {
            "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
            "creation_num": "0"
          }
        }
      }
    },
    {
      "counter": "3"
    },
    {
      "authentication_key": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
      "self_address": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
      "sequence_number": "0"
    }
  ]
}

Use the name of the profile
Additionally, any place that takes an account can use the name of a profile:

$ aptos account list --query resources --account superuser
{
  "Result": [
    {
      "coin": {
        "value": "10000"
      },
      "deposit_events": {
        "counter": "1",
        "guid": {
          "id": {
            "addr": "0x742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc",
            "creation_num": "1"
          }
        }
      },
      "withdraw_events": {
        "counter": "0",
        "guid": {
          "id": {
            "addr": "0x742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc",
            "creation_num": "2"
          }
        }
      }
    },
    {
      "register_events": {
        "counter": "1",
        "guid": {
          "id": {
            "addr": "0x742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc",
            "creation_num": "0"
          }
        }
      }
    },
    {
      "counter": "3"
    },
    {
      "authentication_key": "0x742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc",
      "self_address": "0x742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc",
      "sequence_number": "0"
    }
  ]
}

Listing modules in an account
You can pass different types of queries to view different items under an account. Currently, 'resources' and 'modules' are supported but more query types are coming. For example, to fetch modules:

$ aptos account list --query modules
{
  "Result": [
    {
      "bytecode": "0xa11ceb0b050000000b01000a020a12031c2504410405452d0772da0108cc0240068c030a0a9603150cab03650d90040400000101010201030104000506000006080004070700020e0401060100080001000009020300010f0404000410060100031107000002120709010602130a030106050806080105010802020c0a02000103040508020802070801010a0201060c010800010b0301090002070b030109000900074d657373616765056572726f72056576656e74067369676e657206737472696e67124d6573736167654368616e67654576656e740d4d657373616765486f6c64657206537472696e670b6765745f6d6573736167650b7365745f6d6573736167650c66726f6d5f6d6573736167650a746f5f6d657373616765076d657373616765156d6573736167655f6368616e67655f6576656e74730b4576656e7448616e646c65096e6f745f666f756e6404757466380a616464726573735f6f66106e65775f6576656e745f68616e646c650a656d69745f6576656e74b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb0000000000000000000000000000000000000000000000000000000000000001030800000000000000000002020a08020b08020102020c08020d0b030108000001000101030b0a002901030607001102270b002b0110001402010104010105240b0111030c040e0011040c020a02290120030b05120e000b040e00380012012d0105230b022a010c050a051000140c030a050f010b030a04120038010b040b050f0015020100010100",
      "abi": {
        "address": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
        "name": "Message",
        "friends": [],
        "exposed_functions": [
          {
            "name": "get_message",
            "visibility": "public",
            "is_entry": false,
            "generic_type_params": [],
            "params": [
              "address"
            ],
            "return": [
              "0x1::string::String"
            ]
          },
          {
            "name": "set_message",
            "visibility": "public",
            "is_entry": true,
            "generic_type_params": [],
            "params": [
              "signer",
              "vector<u8>"
            ],
            "return": []
          }
        ],
        "structs": [
          {
            "name": "MessageChangeEvent",
            "is_native": false,
            "abilities": [
              "drop",
              "store"
            ],
            "generic_type_params": [],
            "fields": [
              {
                "name": "from_message",
                "type": "0x1::string::String"
              },
              {
                "name": "to_message",
                "type": "0x1::string::String"
              }
            ]
          },
          {
            "name": "MessageHolder",
            "is_native": false,
            "abilities": [
              "key"
            ],
            "generic_type_params": [],
            "fields": [
              {
                "name": "message",
                "type": "0x1::string::String"
              },
              {
                "name": "message_change_events",
                "type": "0x1::event::EventHandle<0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb::Message::MessageChangeEvent>"
              }
            ]
          }
        ]
      }
    }
  ]
}


Transferring coins
The Aptos CLI is a simple wallet as well, and can transfer coins between accounts.

$ aptos account transfer --account superuser --amount 100
{
  "Result": {
    "gas_used": 73,
    "balance_changes": {
      "742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc": {
        "coin": {
          "value": "10100"
        },
        "deposit_events": {
          "counter": "2",
          "guid": {
            "id": {
              "addr": "0x742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc",
              "creation_num": "1"
            }
          }
        },
        "withdraw_events": {
          "counter": "0",
          "guid": {
            "id": {
              "addr": "0x742854f7dca56ea6309b51e8cebb830b12623f9c9d76c72c3242e4cad353dedc",
              "creation_num": "2"
            }
          }
        }
      },
      "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb": {
        "coin": {
          "value": "9827"
        },
        "deposit_events": {
          "counter": "1",
          "guid": {
            "id": {
              "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
              "creation_num": "1"
            }
          }
        },
        "withdraw_events": {
          "counter": "1",
          "guid": {
            "id": {
              "addr": "0xb9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
              "creation_num": "2"
            }
          }
        }
      }
    },
    "sender": "b9bd2cfa58ca29bce1d7add25fce5c62220604cd0236fe3f90d9de91ed9fb8cb",
    "success": true,
    "version": 1139,
    "vm_status": "Executed successfully"
  }
}

Key
Key examples
Generating a key
To allow generating private keys, you can use the aptos key generate command. You can generate either x25519 or ed25519 keys.

$ aptos key generate --key-type ed25519 --output-file output.key
{
  "Result": {
    "PrivateKey Path": "output.key",
    "PublicKey Path": "output.key.pub"
  }
}

Generating a vanity prefix key
If you are generating an ed25519 key, you can optionally supply a vanity prefix for the corresponding account address:

$ aptos key generate --output-file starts_with_ace.key --vanity-prefix 0xace
{
  "Result": {
    "PrivateKey Path": "starts_with_ace.key",
    "PublicKey Path": "starts_with_ace.key.pub",
    "Account Address:": "0xaceffa015e51dcd32c34794c143e19185b3f1be5464dd6184239a37e57e72ea3"
  }
}

This works for multisig accounts too:

% aptos key generate --output-file starts_with_bee.key --vanity-prefix 0xbee --vanity-multisig
{
  "Result": {
    "PrivateKey Path": "starts_with_bee.key",
    "PublicKey Path": "starts_with_bee.key.pub",
    "Account Address:": "0x384cf987aab625f9727684d4dda8de668abedc18aa8dceabd7651a1cfb69196f",
    "Multisig Account Address:": "0xbee0797c577428249125f6ed7f4a2a5939ddc34389294bd9f5d1627508832f56"
  }
}

Note the vanity flag documentation from the aptos key generate help:

--vanity-multisig
    Use this flag when vanity prefix is for a multisig account. This mines a private key for
    a single signer account that can, as its first transaction, create a multisig account
    with the given vanity prefix

--vanity-prefix <VANITY_PREFIX>
    Vanity prefix that resultant account address should start with, e.g. 0xaceface or d00d.
    Each additional character multiplies by a factor of 16 the computational difficulty
    associated with generating an address, so try out shorter prefixes first and be prepared
    to wait for longer ones

TIP
If you want even faster vanity address generation for long prefixes, try out the parallelism-optimized optivanity tool from Econia Labs

Generating a peer config
To allow others to connect to your node, you need to generate a peer configuration. Below command shows how you can use the aptos CLI to generate a peer configuration and write it into a file named peer_config.yaml.

$ aptos key extract-peer --output-file peer_config.yaml

The above command will generate the following output on the terminal:

{
  "Result": {
    "8cfb85603080b13013b57e2e80887c695cfecd7ad8217d1cac22fa6f3b0b5752": {
      "addresses": [],
      "keys": [
        "0x8cfb85603080b13013b57e2e80887c695cfecd7ad8217d1cac22fa6f3b0b5752"
      ],
      "role": "Upstream"
    }
  }
}

The peer_config.yaml file will be created in your current working directory, with the contents as shown in the below example:

---
8cfb85603080b13013b57e2e80887c695cfecd7ad8217d1cac22fa6f3b0b5752:
  addresses: []
  keys:
    - "0x8cfb85603080b13013b57e2e80887c695cfecd7ad8217d1cac22fa6f3b0b5752"
  role: Upstream

Note: In the addresses key, you should fill in your address.

Node
Node command examples
For Aptos CLI commands applicable to validator nodes, see the Owner and Voter instructions.

Running a local testnet
To learn how to run a local testnet with the Aptos CLI see this guide: Run a Local Development Network with the CLI.

Genesis
Genesis ceremonies
The aptos tool supports bootstrapping new blockchains through what is known as a genesis ceremony. The output of the genesis ceremony is the output of move instructions that prepares a blockchain for online operation. The input consists of:

A set of validators and their configuration
The initial set of Move modules, known as a framework
A unique ChainId (u8) that distinguishes this from other deployments
For test chains, there also exists an account that manages the minting of AptosCoin
Generating genesis
The genesis organizer constructs a Layout and distributes it.
The genesis organizer prepares the Aptos framework's bytecode and distributes it.
Each participant generates their ValidatorConfiguration and distributes it.
Each participant generates a genesis.blob from the resulting contributions.
The genesis organizer executes the genesis.blob to derive the initial waypoint and distributes it.
Each participant begins their aptos-node. The aptos-node verifies upon startup that the genesis.blob with the waypoint provided by the genesis organizer.
The blockchain will begin consensus after a quorum of stake is available.
Prepare aptos-core
The following sections rely on tools from the Aptos source. See Building Aptos From Source for setup.

The layout file
The layout file contains:

root_key: an Ed25519 public key for AptosCoin management.
users: the set of participants
chain_id: the ChainId or a unique integer that distinguishes this deployment from other Aptos networks
An example:

root_key: "0xca3579457555c80fc7bb39964eb298c414fd60f81a2f8eedb0244ec07a26e575"
users:
  - alice
  - bob
chain_id: 8

Building the Aptos Framework
From your Aptos-core repository, build the framework and package it:

cargo run --package framework
mkdir aptos-framework-release
cp aptos-framework/releases/artifacts/current/build/**/bytecode_modules/* aptos-framework-release

The framework will be stored within the aptos-framework-release directory.

The ValidatorConfiguration file
The ValidatorConfiguration file contains:

account_address: The account that manages this validator. This must be derived from the account_key provided within the ValidatorConfiguration file.
consensus_key: The public key for authenticating consensus messages from the validator
account_key: The public key for the account that manages this validator. This is used to derive the account_address.
network_key: The public key for both validator and fullnode network authentication and encryption.
validator_host: The network address where the validator resides. This contains a host and port field. The host should either be a DNS name or an IP address. Currently only IPv4 is supported.
full_node_host: An optional network address where the fullnode resides. This contains a host and port field. The host should either be a DNS name or an IP address. Currently only IPv4 is supported.
stake_amount: The number of coins being staked by this node. This is expected to be 1, if it is different the configuration will be considered invalid.
An example:

account_address: ccd49f3ea764365ac21e99f029ca63a9b0fbfab1c8d8d5482900e4fa32c5448a
consensus_key: "0xa05b8f41057ac72f9ca99f5e3b1b787930f03ba5e448661f2a1fac98371775ee"
account_key: "0x3d15ab64c8b14c9aab95287fd0eb894aad0b4bd929a5581bcc8225b5688f053b"
network_key: "0x43ce1a4ac031b98bb1ee4a5cd72a4cca0fd72933d64b22cef4f1a61895c2e544"
validator_host:
  host: bobs_host
  port: 6180
full_node_host:
  host: bobs_host
  port: 6182
stake_amount: 1

To generate this using the aptos CLI:

Generate your validator's keys:
cargo run --package aptos -- genesis generate-keys --output-dir bobs

Generate your ValidatorConfiguration:
cargo run --package aptos -- \\
    genesis set-validator-configuration \\
    --keys-dir bobs \\
    --username bob \\
    --validator-host bobs_host:6180 \\
    --full-node-host bobs_host:6180 \\
    --local-repository-dir .

The last command will produce a bob.yaml file that should be distributed to other participants for genesis.blob generation.
Generating a genesis and waypoint
genesis.blob and the waypoint can be generated after obtaining the layout file, each of the individual ValidatorConfiguration files, and the framework release. It is important to validate that the ValidatorConfiguration provided in the earlier stage is the same as in the distribution for generating the genesis.blob. If there is a mismatch, inform all participants.

To generate the genesis.blob and waypoint:

Place the layout file in a directory, e.g., genesis.
Place all the ValidatorConfiguration files into the genesis directory.
Ensure that the ValidatorConfiguration files are listed under the set of users within the layout file.
Make a framework directory within the genesiss directory and place the framework release .mv files into the framework directory.
Use the aptos CLI to generate genesis and waypoint:
cargo run --package aptos -- genesis generate-genesis --local-repository-dir genesis

Starting an aptos-node
Upon generating the genesis.blob and waypoint, place them into your validator and fullnode's configuration directory and begin your validator and fullnode.

Use the Aptos CLI with Ledger
The aptos tool can be used with your Ledger device to sign any transaction. This is the most secure way to sign transactions, as your private key never leaves your device.

NOTE: It is highly recommended to use Ledger Nano S Plus or Ledger Nano X devices. The Ledger Nano S device has very limited memory and may not be able to sign most of the transactions. If you are trying to sign a transaction that is too big for your device to handle, you will get an error Wrong raw transaction length.

Blind Signing
Before you begin, make sure you have Blind Signing enabled on your Ledger device. Otherwise you will not be able to sign transactions. Blind Signing - confirming a smart contract interaction you can’t verify through a human readable language.

Create a new Ledger profile
In order to interact with your Ledger device, you must first create a new profile. This profile will be used to store your Ledger public key, and will be used to sign transactions.

$ aptos init --profile myprofile --ledger
Configuring for profile myprofile
Choose network from [devnet, testnet, mainnet, local, custom | defaults to devnet]

No network given, using devnet...
Please choose an index from the following 5 ledger accounts, or choose an arbitrary index that you want to use:
[0] Derivation path: m/44'/637'/0'/0'/0' (Address: 59836ba1dd0c845713bdab34346688d6f1dba290dbf677929f2fc20593ba0cfb)
[1] Derivation path: m/44'/637'/1'/0'/0' (Address: 21563230cf6d69ee72a51d21920430d844ee48235e708edbafbc69708075a86e)
[2] Derivation path: m/44'/637'/2'/0'/0' (Address: 667446181b3b980ef29f5145a7a2cc34d433fc3ee8c97fc044fd978435f2cb8d)
[3] Derivation path: m/44'/637'/3'/0'/0' (Address: 2dcf037a9f31d93e202c074229a1b69ea8ee4d2f2d63323476001c65b0ec4f31)
[4] Derivation path: m/44'/637'/4'/0'/0' (Address: 23c579a9bdde1a59f1c9d36d8d379aeefe7a5997b5b58bd5a5b0c12a4f170431)
0
Account 59836ba1dd0c845713bdab34346688d6f1dba290dbf677929f2fc20593ba0cfb has been already found onchain

---
Aptos CLI is now set up for account 59836ba1dd0c845713bdab34346688d6f1dba290dbf677929f2fc20593ba0cfb as profile myprofile!  Run `aptos --help` for more information about commands
{
  "Result": "Success"
}


In the above, we have created a new profile called myprofile and have chosen to use the first Ledger account (index 0) to sign transactions. If there is a certain index account you would like to use, you are welcome to use it.

After the above command, a new profile will be created in ~/.aptos/config.yml and will look like the following:

  myprofile:
    public_key: "0x05a8ace09d1136181029be3e817de3619562b0da2eedbff210e2b2f92c71be70"
    account: 59836ba1dd0c845713bdab34346688d6f1dba290dbf677929f2fc20593ba0cfb
    rest_url: "https://fullnode.devnet.aptoslabs.com"
    faucet_url: "https://faucet.devnet.aptoslabs.com"
    derivation_path: "m/44'/637'/0'/0'/0'"

Notice that the above stores the derivation path instead of private key. This is because the private key is stored on your Ledger device, and is never exposed to the aptos tool.

Publish a package with Ledger
Once you have created a profile, you can use it to publish a package. The aptos tool will prompt you to confirm the transaction on your Ledger device. Note: Make sure that you are on the same directory as where your move module is located:

$ aptos move publish --profile myprofile --named-addresses hello_blockchain=myprofile
Compiling, may take a little while to download git dependencies...
INCLUDING DEPENDENCY AptosFramework
INCLUDING DEPENDENCY AptosStdlib
INCLUDING DEPENDENCY MoveStdlib
BUILDING Examples
package size 1755 bytes
Do you want to submit a transaction for a range of [139600 - 209400] Octas at a gas unit price of 100 Octas? [yes/no] >
yes
{
  "Result": {
    "transaction_hash": "0xd5a12594f85284cfd5518d547d084030b178ee926fa3d8cbf699cc0596eff538",
    "gas_used": 1396,
    "gas_unit_price": 100,
    "sender": "59836ba1dd0c845713bdab34346688d6f1dba290dbf677929f2fc20593ba0cfb",
    "sequence_number": 0,
    "success": true,
    "timestamp_us": 1689887104333038,
    "version": 126445,
    "vm_status": "Executed successfully"
  }
}


After the above command, you will be prompted to confirm the transaction on your Ledger device. Once you confirm, the transaction will be submitted to the network. Note: Make sure you have Blind Signing enabled on your Ledger device. Otherwise you will not be able to sign transactions. Blind Signing - confirming a smart contract interaction you can’t verify through a human readable language.

Common Errors
Error: Wrong raw transaction length
Your raw transaction or package size is too big. Currently the Aptos ledger app can only support up to 20kb transaction. If you are using a Ledger Nano S, the supported transaction size will be even smaller.

{
  "Error": "Unexpected error: Error - Wrong raw transaction length"
}

Error: Ledger device is locked
Make sure your Ledger device is unlocked and you have Aptos app opened

{
  "Error": "Unexpected error: Error - Ledger device is locked"
}

